Directory structure:
└── arpita21ti-ing/
    ├── create_structure.bat
    ├── db_schemas.txt
    ├── final_dir_stucture_to_follow.md
    ├── go.mod
    ├── go.sum
    ├── structure.txt
    ├── todo.txt
    ├── cmd/
    │   ├── api/
    │   │   └── main.go
    │   ├── migrations/
    │   │   └── main.go
    │   ├── seed/
    │   │   └── main.go
    │   └── worker/
    │       └── main.go
    ├── docs/
    │   ├── api/
    │   │   └── openapi.yaml
    │   ├── architecture/
    │   │   └── domain_model.md
    │   └── guides/
    │       └── getting_started.md
    ├── internal/
    │   ├── .gitignore
    │   ├── analytics/
    │   │   ├── cost/
    │   │   │   └── service_cost_analyzer.go
    │   │   └── usage/
    │   │       └── integration_usage.go
    │   ├── api/
    │   │   ├── rest/
    │   │   │   ├── handler/
    │   │   │   │   ├── quiz/
    │   │   │   │   │   ├── attempt_handler.go
    │   │   │   │   │   └── quiz_handler.go
    │   │   │   │   └── student/
    │   │   │   │       ├── auth_handler.go
    │   │   │   │       └── profile_handler.go
    │   │   │   ├── middleware/
    │   │   │   │   ├── auth.go
    │   │   │   │   ├── logging.go
    │   │   │   │   └── rate_limit.go
    │   │   │   └── router/
    │   │   │       ├── quiz_routes.go
    │   │   │       ├── router.go
    │   │   │       └── student_routes.go
    │   │   └── webhook/
    │   │       ├── canva_webhook.go
    │   │       ├── google_webhook.go
    │   │       └── onesignal_webhook.go
    │   ├── common/
    │   │   ├── errors/
    │   │   │   ├── domain_errors.go
    │   │   │   ├── http_errors.go
    │   │   │   └── infrastructure_errors.go
    │   │   ├── utils/
    │   │   │   ├── pagination.go
    │   │   │   └── security.go
    │   │   └── validator/
    │   │       ├── input_sanitizer.go
    │   │       └── password_validator.go
    │   ├── compliance/
    │   │   ├── integration_auditor.go
    │   │   ├── data_sharing/
    │   │   │   └── consent_manager.go
    │   │   └── gdpr/
    │   │       └── data_processor.go
    │   ├── config/
    │   │   ├── app_config.go
    │   │   ├── credentials.go
    │   │   ├── environment.go
    │   │   ├── feature_flags.go
    │   │   └── integration_config.go
    │   ├── domain/
    │   │   ├── ai/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   ├── coordinator/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   ├── design/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   ├── event/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   ├── integration/
    │   │   │   ├── ai_provider.go
    │   │   │   ├── design_provider.go
    │   │   │   ├── file_storage_provider.go
    │   │   │   └── notification_provider.go
    │   │   ├── platform_profile/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   ├── quiz/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   ├── service.go
    │   │   │   └── question/
    │   │   │       ├── base.go
    │   │   │       ├── fill_blank.go
    │   │   │       ├── mcq.go
    │   │   │       └── true_false.go
    │   │   ├── role/
    │   │   │   ├── model.go
    │   │   │   ├── repository.go
    │   │   │   └── service.go
    │   │   └── student/
    │   │       ├── model.go
    │   │       ├── repository.go
    │   │       ├── service.go
    │   │       └── student/
    │   │           ├── enrollment_master_lookup_table.go
    │   │           ├── leaderboard_lookup_table.go
    │   │           ├── leaderboard_table.go
    │   │           ├── student_academic_details.go
    │   │           ├── student_certification_and_academic_details_table.go
    │   │           ├── student_certification_lookup.go
    │   │           ├── student_documents_table.go
    │   │           ├── student_family_details_table.go
    │   │           ├── student_log_in_details_table.go
    │   │           ├── student_practice_session_lookup_table.go
    │   │           ├── student_practice_sessions_record_table.go
    │   │           ├── student_profile_details.go
    │   │           └── student_scholarship_details_table.go
    │   ├── eventbus/
    │   │   ├── events/
    │   │   │   ├── quiz_events.go
    │   │   │   └── student_events.go
    │   │   ├── publisher/
    │   │   │   └── kafka_publisher.go
    │   │   └── subscriber/
    │   │       └── kafka_subscriber.go
    │   ├── infrastructure/
    │   │   ├── auth/
    │   │   │   ├── api_key_manager.go
    │   │   │   ├── jwt_provider.go
    │   │   │   └── oauth_client.go
    │   │   ├── cache/
    │   │   │   ├── local_cache.go
    │   │   │   └── redis_cache.go
    │   │   ├── database/
    │   │   │   ├── mongodb/
    │   │   │   │   └── connection.go
    │   │   │   └── postgres/
    │   │   │       ├── connection.go
    │   │   │       └── repositories/
    │   │   │           ├── platform_profile_repo.go
    │   │   │           ├── quiz_repo.go
    │   │   │           └── student_repo.go
    │   │   ├── discovery/
    │   │   │   └── service_registry.go
    │   │   ├── email/
    │   │   │   ├── smtp_provider.go
    │   │   │   └── template_engine.go
    │   │   ├── fallback/
    │   │   │   ├── notification_fallback.go
    │   │   │   └── storage_fallback.go
    │   │   ├── integration/
    │   │   │   ├── canva/
    │   │   │   │   └── design_client.go
    │   │   │   ├── factory/
    │   │   │   │   ├── ai_factory.go
    │   │   │   │   ├── notification_factory.go
    │   │   │   │   └── storage_factory.go
    │   │   │   ├── google/
    │   │   │   │   ├── auth.go
    │   │   │   │   ├── calendar.go
    │   │   │   │   └── drive.go
    │   │   │   ├── huggingface/
    │   │   │   │   ├── client.go
    │   │   │   │   └── model_manager.go
    │   │   │   ├── onesignal/
    │   │   │   │   └── notification_client.go
    │   │   │   └── versioning/
    │   │   │       └── version_manager.go
    │   │   ├── migration/
    │   │   │   └── service_switcher.go
    │   │   ├── monitoring/
    │   │   │   ├── integration_health.go
    │   │   │   └── alerts/
    │   │   │       └── service_degradation.go
    │   │   ├── offline/
    │   │   │   └── offline_queue.go
    │   │   ├── quota/
    │   │   │   ├── limit_tracker.go
    │   │   │   └── throttling_service.go
    │   │   ├── sdk/
    │   │   │   ├── google_sdk_wrapper.go
    │   │   │   └── huggingface_sdk_wrapper.go
    │   │   └── storage/
    │   │       ├── local_storage.go
    │   │       └── s3_storage.go
    │   ├── security/
    │   │   └── scanner/
    │   │       └── integration_scanner.go
    │   ├── tenant/
    │   │   └── integration_config.go
    │   └── worker/
    │       ├── analytics/
    │       │   └── report_worker.go
    │       ├── email/
    │       │   └── notification_worker.go
    │       └── notification/
    │           └── push_worker.go
    ├── migrations/
    │   └── postgres/
    │       ├── 000001_create_students.down.sql
    │       └── 000001_create_students.up.sql
    ├── pkg/
    │   ├── logger/
    │   │   └── logger.go
    │   ├── pagination/
    │   │   └── paginator.go
    │   └── security/
    │       └── password.go
    ├── scripts/
    │   ├── ci/
    │   │   ├── build.sh
    │   │   └── test.sh
    │   ├── deploy/
    │   │   └── docker-compose.yml
    │   └── local/
    │       └── setup.sh
    ├── seeds/
    │   ├── seed_runner.go
    │   ├── development/
    │   │   ├── 001_roles.go
    │   │   ├── 002_admin_users.go
    │   │   └── 003_sample_data.go
    │   ├── production/
    │   │   ├── default_settings.go
    │   │   └── initial_roles.go
    │   └── testing/
    │       ├── test_scenarios.go
    │       └── test_users.go
    └── test/
        ├── fixtures/
        │   └── students.json
        └── integration/
            ├── db_test_helper.go
            └── external/
                ├── google_test.go
                ├── onesignal_test.go
                └── mock_services/
                    └── mock_google_api.go

================================================
File: create_structure.bat
================================================
@echo off

REM cmd directory
mkdir cmd\api cmd\worker cmd\migrations cmd\seed
type nul > cmd\api\main.go
type nul > cmd\worker\main.go
type nul > cmd\migrations\main.go
type nul > cmd\seed\main.go

REM seeds directory
mkdir seeds\development seeds\testing seeds\production
type nul > seeds\development\001_roles.go
type nul > seeds\development\002_admin_users.go
type nul > seeds\development\003_sample_data.go
type nul > seeds\testing\test_users.go
type nul > seeds\testing\test_scenarios.go
type nul > seeds\production\initial_roles.go
type nul > seeds\production\default_settings.go
type nul > seeds\seed_runner.go

REM internal directory - security, analytics, tenant, compliance
mkdir internal\security\scanner internal\analytics\usage internal\analytics\cost internal\tenant internal\compliance\gdpr internal\compliance\data_sharing internal\compliance\audit
type nul > internal\security\scanner\integration_scanner.go
type nul > internal\analytics\usage\integration_usage.go
type nul > internal\analytics\cost\service_cost_analyzer.go
type nul > internal\tenant\integration_config.go
type nul > internal\compliance\gdpr\data_processor.go
type nul > internal\compliance\data_sharing\consent_manager.go
type nul > internal\compliance\integration_auditor.go

REM internal directory - domain
mkdir internal\domain\student internal\domain\quiz\question internal\domain\event internal\domain\coordinator internal\domain\role internal\domain\integration internal\domain\ai internal\domain\design
type nul > internal\domain\student\model.go
type nul > internal\domain\student\repository.go
type nul > internal\domain\student\service.go
type nul > internal\domain\quiz\model.go
type nul > internal\domain\quiz\repository.go
type nul > internal\domain\quiz\service.go
type nul > internal\domain\quiz\question\base.go
type nul > internal\domain\quiz\question\mcq.go
type nul > internal\domain\quiz\question\fill_blank.go
type nul > internal\domain\quiz\question\true_false.go
type nul > internal\domain\event\model.go
type nul > internal\domain\event\repository.go
type nul > internal\domain\event\service.go
type nul > internal\domain\coordinator\model.go
type nul > internal\domain\coordinator\repository.go
type nul > internal\domain\coordinator\service.go
type nul > internal\domain\role\model.go
type nul > internal\domain\role\repository.go
type nul > internal\domain\role\service.go
type nul > internal\domain\integration\notification_provider.go
type nul > internal\domain\integration\file_storage_provider.go
type nul > internal\domain\integration\ai_provider.go
type nul > internal\domain\integration\design_provider.go
type nul > internal\domain\ai\model.go
type nul > internal\domain\ai\repository.go
type nul > internal\domain\ai\service.go
type nul > internal\domain\design\model.go
type nul > internal\domain\design\repository.go
type nul > internal\domain\design\service.go

REM internal directory - api
mkdir internal\api\rest\handler\student internal\api\rest\handler\quiz internal\api\rest\middleware internal\api\rest\dto\request internal\api\rest\dto\response internal\api\rest\router internal\api\rest\ai internal\api\rest\design internal\api\graphql\resolver internal\api\graphql\schema internal\api\graphql\directive internal\api\webhook
type nul > internal\api\rest\handler\student\auth_handler.go
type nul > internal\api\rest\handler\student\profile_handler.go
type nul > internal\api\rest\handler\quiz\quiz_handler.go
type nul > internal\api\rest\handler\quiz\attempt_handler.go
type nul > internal\api\rest\middleware\auth.go
type nul > internal\api\rest\middleware\logging.go
type nul > internal\api\rest\middleware\rate_limit.go
type nul > internal\api\rest\router\router.go
type nul > internal\api\rest\router\student_routes.go
type nul > internal\api\rest\router\quiz_routes.go
type nul > internal\api\webhook\google_webhook.go
type nul > internal\api\webhook\onesignal_webhook.go
type nul > internal\api\webhook\canva_webhook.go

REM internal directory - infrastructure
mkdir internal\infrastructure\migration internal\infrastructure\offline internal\infrastructure\discovery internal\infrastructure\quota internal\infrastructure\monitoring\alerts internal\infrastructure\fallback internal\infrastructure\sdk internal\infrastructure\database\postgres\migrations internal\infrastructure\database\postgres\repositories internal\infrastructure\database\mongodb\repositories internal\infrastructure\auth internal\infrastructure\email internal\infrastructure\storage internal\infrastructure\cache internal\infrastructure\integration\versioning internal\infrastructure\integration\google internal\infrastructure\integration\onesignal internal\infrastructure\integration\huggingface internal\infrastructure\integration\canva internal\infrastructure\integration\factory
type nul > internal\infrastructure\migration\service_switcher.go
type nul > internal\infrastructure\offline\offline_queue.go
type nul > internal\infrastructure\discovery\service_registry.go
type nul > internal\infrastructure\quota\limit_tracker.go
type nul > internal\infrastructure\quota\throttling_service.go
type nul > internal\infrastructure\monitoring\integration_health.go
type nul > internal\infrastructure\monitoring\alerts\service_degradation.go
type nul > internal\infrastructure\fallback\notification_fallback.go
type nul > internal\infrastructure\fallback\storage_fallback.go
type nul > internal\infrastructure\sdk\google_sdk_wrapper.go
type nul > internal\infrastructure\sdk\huggingface_sdk_wrapper.go
type nul > internal\infrastructure\database\postgres\connection.go
type nul > internal\infrastructure\database\postgres\repositories\student_repo.go
type nul > internal\infrastructure\database\postgres\repositories\quiz_repo.go
type nul > internal\infrastructure\database\mongodb\connection.go
type nul > internal\infrastructure\auth\jwt_provider.go
type nul > internal\infrastructure\auth\oauth_client.go
type nul > internal\infrastructure\auth\api_key_manager.go
type nul > internal\infrastructure\email\smtp_provider.go
type nul > internal\infrastructure\email\template_engine.go
type nul > internal\infrastructure\storage\local_storage.go
type nul > internal\infrastructure\storage\s3_storage.go
type nul > internal\infrastructure\cache\redis_cache.go
type nul > internal\infrastructure\cache\local_cache.go
type nul > internal\infrastructure\integration\versioning\version_manager.go
type nul > internal\infrastructure\integration\google\auth.go
type nul > internal\infrastructure\integration\google\calendar.go
type nul > internal\infrastructure\integration\google\drive.go
type nul > internal\infrastructure\integration\onesignal\notification_client.go
type nul > internal\infrastructure\integration\huggingface\client.go
type nul > internal\infrastructure\integration\huggingface\model_manager.go
type nul > internal\infrastructure\integration\canva\design_client.go
type nul > internal\infrastructure\integration\factory\notification_factory.go
type nul > internal\infrastructure\integration\factory\storage_factory.go
type nul > internal\infrastructure\integration\factory\ai_factory.go

REM internal directory - worker
mkdir internal\worker\email internal\worker\notification internal\worker\analytics
type nul > internal\worker\email\notification_worker.go
type nul > internal\worker\notification\push_worker.go
type nul > internal\worker\analytics\report_worker.go

REM internal directory - config
mkdir internal\config
type nul > internal\config\app_config.go
type nul > internal\config\environment.go
type nul > internal\config\feature_flags.go
type nul > internal\config\integration_config.go
type nul > internal\config\credentials.go

REM internal directory - common
mkdir internal\common\validator internal\common\errors internal\common\utils
type nul > internal\common\validator\password_validator.go
type nul > internal\common\validator\input_sanitizer.go
type nul > internal\common\errors\domain_errors.go
type nul > internal\common\errors\http_errors.go
type nul > internal\common\utils\pagination.go
type nul > internal\common\utils\security.go

REM internal directory - eventbus
mkdir internal\eventbus\events internal\eventbus\publisher internal\eventbus\subscriber
type nul > internal\eventbus\events\student_events.go
type nul > internal\eventbus\events\quiz_events.go
type nul > internal\eventbus\publisher\kafka_publisher.go
type nul > internal\eventbus\subscriber\kafka_subscriber.go

REM pkg directory
mkdir pkg\logger pkg\pagination pkg\security
type nul > pkg\logger\logger.go
type nul > pkg\pagination\paginator.go
type nul > pkg\security\password.go

REM migrations directory
mkdir migrations\postgres migrations\mongodb
type nul > migrations\postgres\000001_create_students.up.sql
type nul > migrations\postgres\000001_create_students.down.sql

REM scripts directory
mkdir scripts\deploy\kubernetes scripts\ci scripts\local
type nul > scripts\deploy\docker-compose.yml
type nul > scripts\ci\build.sh
type nul > scripts\ci\test.sh
type nul > scripts\local\setup.sh

REM docs directory
mkdir docs\integrations\setup_guides docs\integrations\api_references docs\api docs\architecture docs\guides
type nul > docs\api\openapi.yaml
type nul > docs\architecture\domain_model.md
type nul > docs\guides\getting_started.md

REM test directory
mkdir test\integration\external\mock_services test\mocks\repositories test\fixtures
type nul > test\integration\db_test_helper.go
type nul > test\integration\external\google_test.go
type nul > test\integration\external\onesignal_test.go
type nul > test\integration\external\mock_services\mock_google_api.go
type nul > test\fixtures\students.json

REM Add root files
type nul > .env.example
type nul > .gitignore

echo Directory structure created successfully!


================================================
File: db_schemas.txt
================================================
Schemas:
profile_schema 

Tables:
platform_profiles
deleted_profiles . Add the deleted_at column.



================================================
File: final_dir_stucture_to_follow.md
================================================
# The main dir structure for scale-able design

```text
TNP_RGPV_SERVER/
├── cmd/                                 # Command-line entry points
│   ├── api/                             # REST API server entry point
│   │   └── main.go                      # Server initialization, config loading, router setup
│   ├── worker/                          # Background job processor
│   │   └── main.go                      # Worker initialization, queue consumption
│   ├── migrations/                      # Database migration tool
│   │   └── main.go                      # DB migration execution utility
│   └── seed/                             # Seed command entry point
│      └── main.go                       # CLI for running seeds
├── seeds/                              # Database seeding scripts
│   ├── development/                    # Development environment seeds
│   │   ├── 001_roles.go                # Basic role definitions
│   │   ├── 002_admin_users.go          # Admin user accounts
│   │   └── 003_sample_data.go          # Sample data for development
│   ├── testing/                        # Test environment seeds
│   │   ├── test_users.go               # Test user accounts
│   │   └── test_scenarios.go           # Specific test scenarios
│   ├── production/                     # Production environment seeds
│   │   ├── initial_roles.go            # Initial roles for production
│   │   └── default_settings.go         # Default system settings
│   └── seed_runner.go                  # Script to run seeds in sequence
├── internal/                            # Private application code
|   ├── security/                             # Security framework
|   │   └── scanner/                          # Security scanning
|   │       └── integration_scanner.go        # Scans for security issues in integrations
|   ├── analytics/                            # Analytics framework
|   │   ├── usage/                            # Usage analytics
|   │   │   └── integration_usage.go          # Tracks integration usage patterns
|   │   └── cost/                             # Cost analysis
|   │       └── service_cost_analyzer.go      # Analyzes costs of external services
|   ├── tenant/                               # Multi-tenant support. If different departments or faculties need different integration configurations.
|   │   └── integration_config.go             # Tenant-specific integration settings
|   ├── compliance/                           # Compliance management
|   │   ├── gdpr/                             # GDPR compliance handling
|   │   │   └── data_processor.go             # Handles data subject rights
|   │   ├── data_sharing/                     # Data sharing controls
|   │   │   └── consent_manager.go            # Manages user consent for data sharing
|   │   |── audit/                            # Audit logging for compliance
│   |   └── integration_auditor.go        # Audits interactions with external services
│   ├── domain/                          # Core domain models & business logic
│   │   ├── student/                     # Student domain
│   │   │   ├── model.go                 # Student entity definitions, value objects
│   │   │   ├── repository.go            # Student repository interface
│   │   │   └── service.go               # Student business logic, validation rules
│   │   ├── quiz/                        # Quiz management domain
│   │   │   ├── model.go                 # Quiz entities and relationships
│   │   │   ├── question/                # Question type hierarchy
│   │   │   │   ├── base.go              # Question interface and common functionality
│   │   │   │   ├── mcq.go               # Multiple choice question implementation
│   │   │   │   ├── fill_blank.go        # Fill-in-the-blank question implementation
│   │   │   │   └── true_false.go        # True/False question implementation
│   │   │   ├── repository.go            # Quiz repository interface
│   │   │   └── service.go               # Quiz business logic, scoring rules
│   │   ├── event/                       # Event management domain
│   │   │   ├── model.go                 # Event entities, scheduling entities
│   │   │   ├── repository.go            # Event repository interface
│   │   │   └── service.go               # Event business logic, validation rules
│   │   ├── coordinator/                 # Coordinator domain
│   │   │   ├── model.go                 # Coordinator entities and relationships
│   │   │   ├── repository.go            # Coordinator repository interface
│   │   │   └── service.go               # Coordinator-specific business logic
│   │   ├── role/                        # Role-based permissions system
│   │   │   ├── model.go                 # Role definitions, permission entities
│   │   │   ├── repository.go            # Role repository interface
│   │   │   └── service.go               # Permission checking, role assignment logic
|   |   ├── integration/                   # Integration interfaces
|   |   │   ├── notification_provider.go   # Abstract notification service
|   |   │   ├── file_storage_provider.go   # Abstract file storage
|   |   │   ├── ai_provider.go             # Abstract AI service
|   |   │   └── design_provider.go         # Abstract design service
|   │   ├── ai/                                # AI features domain
|   │   │   ├── model.go                       # AI model entities
|   │   │   ├── repository.go                  # AI model repository
|   │   │   └── service.go                     # AI services (using Hugging Face)
|   │   ├── design/                            # Design features domain
|   │   │   ├── model.go                       # Design entities
|   │   │   ├── repository.go                  # Design repository
|   │   │   └── service.go                     # Design services (using Canva)
│   │   └── [other domains]              # Additional business domains
│   ├── api/                             # API layer
│   │   ├── rest/                        # REST API
│   │   │   ├── handler/                 # Request handlers
│   │   │   │   ├── student/             # Student-related endpoint handlers
│   │   │   │   │   ├── auth_handler.go  # Student authentication endpoints
│   │   │   │   │   └── profile_handler.go # Student profile management endpoints
│   │   │   │   ├── quiz/                # Quiz-related endpoint handlers
│   │   │   │   │   ├── quiz_handler.go  # Quiz CRUD operations
│   │   │   │   │   └── attempt_handler.go # Quiz attempt submission/retrieval
│   │   │   │   └── [other domains]      # Additional domain endpoint handlers
│   │   │   ├── middleware/              # HTTP middleware
│   │   │   │   ├── auth.go              # Authentication/authorization middleware
│   │   │   │   ├── logging.go           # Request logging middleware
│   │   │   │   └── rate_limit.go        # Rate limiting middleware
│   │   │   ├── dto/                     # Data transfer objects
│   │   │   │   ├── request/             # Request models for API endpoints
│   │   │   │   └── response/            # Response models for API endpoints
│   │   │   |── router/                  # Router configuration
│   │   │   |   ├── router.go            # Main router setup
│   │   │   |   ├── student_routes.go    # Student endpoint registration
│   │   │   |   └── quiz_routes.go       # Quiz endpoint registration
|   │   │   ├── ai/                        # AI feature endpoints
|   │   │   └── design/                    # Design feature endpoints
│   │   |── graphql/                     # Future GraphQL API
│   │   |   ├── resolver/                # GraphQL resolvers for each domain
│   │   |   ├── schema/                  # GraphQL schema definitions
│   │   |  └── directive/               # Custom GraphQL directives
|   │   └── webhook/                           # Webhook handlers
|   │       ├── google_webhook.go              # Google webhook handlers
|   │       ├── onesignal_webhook.go           # OneSignal webhook handlers
|   │       └── canva_webhook.go               # Canva webhook handlers
│   ├── infrastructure/                  # External dependencies
|   │   ├── migration/                        # Feature migration framework
|   │   │   └── service_switcher.go           # Handles switching between service providers
|   │   ├── offline/                          # Offline operation support
|   │   │   └── offline_queue.go              # Queues operations for when online
|   │   ├── discovery/                        # Service discovery
|   │   │   └── service_registry.go           # Dynamic service endpoint discovery
|   │   ├── quota/                            # API quota management
|   │   │   ├── limit_tracker.go              # Tracks API usage against limits
|   │   │   └── throttling_service.go         # Implements request throttling
|   │   ├── monitoring/                       # Health monitoring
|   │   │   ├── integration_health.go         # Integration health checks
|   │   │   └── alerts/                       # Alert system for service issues
|   │   │       └── service_degradation.go    # Handles service degradation alerts
|   │   ├── fallback/
|   |   │   ├── notification_fallback.go       # Fallback notification delivery
|   |   │   └── storage_fallback.go            # Fallback storage options
|   │   ├── sdk/                               # SDK wrappers
|   │   │   ├── google_sdk_wrapper.go          # Google SDK wrapper
|   │   │   └── huggingface_sdk_wrapper.go     # Hugging Face SDK wrapper
│   │   ├── database/                    # Database adapters
│   │   │   ├── postgres/                # PostgreSQL adapter
│   │   │   │   ├── connection.go        # Connection pool management
│   │   │   │   ├── migrations/          # Postgres-specific migrations
│   │   │   │   └── repositories/        # Concrete repository implementations
│   │   │   │       ├── student_repo.go  # Student repository PostgreSQL implementation
│   │   │   │       └── quiz_repo.go     # Quiz repository PostgreSQL implementation
│   │   │   └── mongodb/                 # MongoDB adapter
│   │   │       ├── connection.go        # MongoDB connection management
│   │   │       └── repositories/        # MongoDB repository implementations
│   │   ├── auth/                        # Auth providers
│   │   │   └── jwt_provider.go          # JWT token generation/validation
|   │   │   ├── oauth_client.go                # OAuth client implementation
|   │   │   └── api_key_manager.go             # API key management
│   │   ├── email/                       # Email service
│   │   │   ├── smtp_provider.go         # SMTP email sender implementation
│   │   │   └── template_engine.go       # Email template rendering
│   │   ├── storage/                     # File storage
│   │   │   ├── local_storage.go         # Local filesystem storage
│   │   │   └── s3_storage.go            # S3 compatible storage
│   │   |── cache/                       # Caching layer
│   │   │    ├── redis_cache.go           # Redis cache implementation
│   │   │    └── local_cache.go           # In-memory cache implementation
|   |   └── integration/                       # Third-party service integrations
|   │   │   ├── versioning/                   # API version management
|   │   │   │   └── version_manager.go        # Handles API version transitions
|   |   |   ├── google/                        # Google services integration
|   |   |   │   ├── auth.go                    # Google OAuth implementation
|   |   |   │   ├── calendar.go                # Google Calendar integration
|   |   |   │   └── drive.go                   # Google Drive integration
|   |   |   ├── onesignal/                     # OneSignal push notifications
|   |   |   │   └── notification_client.go     # OneSignal API client
|   |   |   ├── huggingface/                   # Hugging Face AI models
|   |   |   │   ├── client.go                  # API client for Hugging Face
|   |   |   │   └── model_manager.go           # AI model management
|   |   |   |── canva/                         # Canva design integration
|   |   |   |   └── design_client.go           # Canva API client
|   |   │   └── factory/
|   |   │       ├── notification_factory.go        # Creates notification providers
|   |   │       ├── storage_factory.go             # Creates storage providers
|   |   │       └── ai_factory.go                  # Creates AI service providers
│   ├── worker/                          # Background jobs
│   │   ├── email/                       # Email sending workers
│   │   │   └── notification_worker.go   # Sends email notifications 
│   │   ├── notification/                # Push notification workers
│   │   │   └── push_worker.go           # Sends push notifications
│   │   └── analytics/                   # Analytics processing
│   │       └── report_worker.go         # Generates periodic reports
│   ├── config/                          # Configuration
│   │   ├── app_config.go                # Application configuration loader
│   │   ├── environment.go               # Environment variable handling
│   │   |── feature_flags.go             # Feature toggle support
|   │   ├── integration_config.go        # Third-party integration config
|   │   └── credentials.go               # Secure credential management
│   ├── common/                          # Cross-cutting concerns
│   │   ├── validator/                   # Validation logic
│   │   │   ├── password_validator.go    # Password strength validation
│   │   │   └── input_sanitizer.go       # Input sanitization functions
│   │   ├── errors/                      # Error types & handling
│   │   │   ├── domain_errors.go         # Domain-specific error types
│   │   │   └── http_errors.go           # HTTP error handling utilities
│   │   └── utils/                       # Shared utilities
│   │       ├── pagination.go            # Pagination helpers
│   │       └── security.go              # Security-related helpers
│   └── eventbus/                        # Event-driven architecture
│       ├── events/                      # Event definitions
│       │   ├── student_events.go        # Student-related events
│       │   └── quiz_events.go           # Quiz-related events
│       ├── publisher/                   # Event publishers
│       │   └── kafka_publisher.go       # Kafka implementation of event publishing
│       └── subscriber/                  # Event subscribers
│           └── kafka_subscriber.go      # Kafka implementation of event consumption
├── pkg/                                 # Public packages
│   ├── logger/                          # Logging utility
│   │   └── logger.go                    # Structured logging implementation
│   ├── pagination/                      # Reusable pagination
│   │   └── paginator.go                 # Generic pagination implementation
│   └── security/                        # Security utilities
│       └── password.go                  # Password hashing & verification
├── migrations/                          # Database migrations
│   ├── postgres/                        # PostgreSQL migrations
│   │   ├── 000001_create_students.up.sql   # Migration to create students table
│   │   └── 000001_create_students.down.sql # Rollback for students table
│   └── mongodb/                         # MongoDB migrations/seed scripts
├── scripts/                             # CI/CD, deployment scripts
│   ├── deploy/                          # Deployment scripts
│   │   ├── kubernetes/                  # K8s deployment manifests
│   │   └── docker-compose.yml           # Docker compose for local dev
│   ├── ci/                              # CI pipeline scripts
│   │   ├── build.sh                     # Build script for CI
│   │   └── test.sh                      # Test execution script
│   └── local/                           # Local development scripts
│       └── setup.sh                     # Local dev environment setup
├── docs/                                # Documentation
|   ├── integrations/                         # Integration documentation
|   │   ├── setup_guides/                     # Setup guides for each integration
|   │   └── api_references/                   # API reference for integration points
│   ├── api/                             # API documentation
│   │   └── openapi.yaml                 # OpenAPI/Swagger specification
│   ├── architecture/                    # Architecture docs
│   │   └── domain_model.md              # Domain model documentation
│   └── guides/                          # Guides for developers
│       └── getting_started.md           # Developer onboarding guide
├── test/                                # Test helpers and fixtures
│   ├── integration/                     # Integration test helpers
│   │   |── db_test_helper.go            # Database test utilities
|   │   └── external/                         # External service tests
|   │       ├── google_test.go                # Google API integration tests
|   │       ├── onesignal_test.go             # OneSignal integration tests
|   │       └── mock_services/                # Mock implementations for testing
|   │           └── mock_google_api.go        # Mock Google API responses
│   ├── mocks/                           # Mock implementations
│   │   └── repositories/                # Mock repository implementations
│   └── fixtures/                        # Test data fixtures
│       └── students.json                # Sample student data for tests
├── .env.example                         # Example environment variables
├── .gitignore                           # Git ignore file
├── go.mod                               # Go module definition
└── go.sum                               # Go module checksums
```



================================================
File: go.mod
================================================
module server

go 1.24.1

require (
	github.com/bytedance/sonic v1.12.6 // indirect
	github.com/bytedance/sonic/loader v0.2.1 // indirect
	github.com/cloudwego/base64x v0.1.4 // indirect
	github.com/cloudwego/iasm v0.2.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.7 // indirect
	github.com/gin-contrib/cors v1.7.3 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/gin-gonic/gin v1.10.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.23.0 // indirect
	github.com/goccy/go-json v0.10.4 // indirect
	github.com/golang-jwt/jwt/v5 v5.2.1 // indirect
	github.com/golang-migrate/migrate/v4 v4.18.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/hashicorp/errwrap v1.1.0 // indirect
	github.com/hashicorp/go-multierror v1.1.1 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/pgx/v5 v5.7.2 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.9 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	go.uber.org/atomic v1.11.0 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
	golang.org/x/arch v0.12.0 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/net v0.33.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/sys v0.28.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	google.golang.org/protobuf v1.36.1 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)



================================================
File: go.sum
================================================
github.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=
github.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=
github.com/bytedance/sonic v1.12.6 h1:/isNmCUF2x3Sh8RAp/4mh4ZGkcFAX/hLrzrK3AvpRzk=
github.com/bytedance/sonic v1.12.6/go.mod h1:B8Gt/XvtZ3Fqj+iSKMypzymZxw/FVwgIGKzMzT9r/rk=
github.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=
github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/bytedance/sonic/loader v0.2.1 h1:1GgorWTqf12TA8mma4DDSbaQigE2wOgQo7iCjjJv3+E=
github.com/bytedance/sonic/loader v0.2.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
github.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=
github.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
github.com/gabriel-vasile/mimetype v1.4.7 h1:SKFKl7kD0RiPdbht0s7hFtjl489WcQ1VyPW8ZzUMYCA=
github.com/gabriel-vasile/mimetype v1.4.7/go.mod h1:GDlAgAyIRT27BhFl53XNAFtfjzOkLaF35JdEG0P7LtU=
github.com/gin-contrib/cors v1.7.3 h1:hV+a5xp8hwJoTw7OY+a70FsL8JkVVFTXw9EcfrYUdns=
github.com/gin-contrib/cors v1.7.3/go.mod h1:M3bcKZhxzsvI+rlRSkkxHyljJt1ESd93COUvemZ79j4=
github.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=
github.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=
github.com/gin-gonic/gin v1.10.0 h1:nTuyha1TYqgedzytsKYqna+DfLos46nTv2ygFy86HFU=
github.com/gin-gonic/gin v1.10.0/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
github.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=
github.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/go-playground/validator/v10 v10.23.0 h1:/PwmTwZhS0dPkav3cdK9kV1FsAmrL8sThn8IHr/sO+o=
github.com/go-playground/validator/v10 v10.23.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
github.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=
github.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
github.com/goccy/go-json v0.10.4 h1:JSwxQzIqKfmFX1swYPpUThQZp/Ka4wzJdK0LWVytLPM=
github.com/goccy/go-json v0.10.4/go.mod h1:oq7eo15ShAhp70Anwd5lgX2pLfOS3QCiwU/PULtXL6M=
github.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=
github.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=
github.com/golang-migrate/migrate/v4 v4.18.2 h1:2VSCMz7x7mjyTXx3m2zPokOY82LTRgxK1yQYKo6wWQ8=
github.com/golang-migrate/migrate/v4 v4.18.2/go.mod h1:2CM6tJvn2kqPXwnXO/d3rAQYiyoIm180VsO8PRX6Rpk=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/errwrap v1.1.0 h1:OxrOeh75EUXMY8TBjag2fzXGZ40LB6IKw45YeGUDY2I=
github.com/hashicorp/errwrap v1.1.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+lD48awMYo=
github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.2 h1:mLoDLV6sonKlvjIEsV56SkWNCnuNv531l94GaIzO+XI=
github.com/jackc/pgx/v5 v5.7.2/go.mod h1:ncY89UGWxg82EykZUwSpUKEfccBGGYq1xjrOpsbsfGQ=
github.com/jackc/puddle/v2 v2.2.2 h1:PR8nw+E/1w0GLuRFSmiioY6UooMp6KJv0/61nB7icHo=
github.com/jackc/puddle/v2 v2.2.2/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
github.com/klauspost/cpuid/v2 v2.2.9 h1:66ze0taIn2H33fBvCkXuv9BmCwDfafmiIVpKV9kKGuY=
github.com/klauspost/cpuid/v2 v2.2.9/go.mod h1:rqkxqrZ1EhYM9G+hXH7YdowN5R5RGN6NK4QwQ3WMXF8=
github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=
github.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=
github.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=
github.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
go.uber.org/atomic v1.7.0 h1:ADUqmZGgLDDfbSL9ZmPxKTybcoEYHgpYfELNoN+7hsw=
go.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
go.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=
go.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
golang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=
golang.org/x/arch v0.8.0 h1:3wRIsP3pM4yUptoR96otTUOXI367OS0+c9eeRi9doIc=
golang.org/x/arch v0.8.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
golang.org/x/arch v0.12.0 h1:UsYJhbzPYGsT0HbEdmYcqtCv8UNGvnaL561NnIUvaKg=
golang.org/x/arch v0.12.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
golang.org/x/crypto v0.23.0 h1:dIJU/v2J8Mdglj/8rJ6UUOM3Zc9zLZxVZwwxMooUSAI=
golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
golang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=
golang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=
golang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=
golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
golang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=
golang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=
golang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=
golang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=
golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=
golang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.15.0 h1:h1V/4gjBv8v9cjcR6+AR5+/cIYK5N/WAgiv4xlsEtAk=
golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
golang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=
golang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=
google.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=
google.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
google.golang.org/protobuf v1.36.1 h1:yBPeRvTftaleIgM3PZ/WBIZ7XM/eEYAaEyCwvyjq/gk=
google.golang.org/protobuf v1.36.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=



================================================
File: structure.txt
================================================
Folder PATH listing for volume DATA
Volume serial number is CAEC-4F8F
D:.
|   .env.example
|   .gitignore
|   create_structure.bat
|   final_dir_stucture_to_follow.md
|   go.mod
|   go.sum
|   structure.txt
|   
+---cmd
|   +---api
|   |       main.go
|   |       
|   +---migrations
|   |       main.go
|   |       
|   +---seed
|   |       main.go
|   |       
|   \---worker
|           main.go
|           
+---docs
|   +---api
|   |       openapi.yaml
|   |       
|   +---architecture
|   |       domain_model.md
|   |       
|   +---guides
|   |       getting_started.md
|   |       
|   \---integrations
|       +---api_references
|       \---setup_guides
+---internal
|   +---analytics
|   |   +---cost
|   |   |       service_cost_analyzer.go
|   |   |       
|   |   \---usage
|   |           integration_usage.go
|   |           
|   +---api
|   |   +---graphql
|   |   |   +---directive
|   |   |   +---resolver
|   |   |   \---schema
|   |   +---rest
|   |   |   +---ai
|   |   |   +---design
|   |   |   +---dto
|   |   |   |   +---request
|   |   |   |   \---response
|   |   |   +---handler
|   |   |   |   +---quiz
|   |   |   |   |       attempt_handler.go
|   |   |   |   |       quiz_handler.go
|   |   |   |   |       
|   |   |   |   \---student
|   |   |   |           auth_handler.go
|   |   |   |           profile_handler.go
|   |   |   |           
|   |   |   +---middleware
|   |   |   |       auth.go
|   |   |   |       logging.go
|   |   |   |       rate_limit.go
|   |   |   |       
|   |   |   \---router
|   |   |           quiz_routes.go
|   |   |           router.go
|   |   |           student_routes.go
|   |   |           
|   |   \---webhook
|   |           canva_webhook.go
|   |           google_webhook.go
|   |           onesignal_webhook.go
|   |           
|   +---common
|   |   +---errors
|   |   |       domain_errors.go
|   |   |       http_errors.go
|   |   |       
|   |   +---utils
|   |   |       pagination.go
|   |   |       security.go
|   |   |       
|   |   \---validator
|   |           input_sanitizer.go
|   |           password_validator.go
|   |           
|   +---compliance
|   |   |   integration_auditor.go
|   |   |   
|   |   +---audit
|   |   +---data_sharing
|   |   |       consent_manager.go
|   |   |       
|   |   \---gdpr
|   |           data_processor.go
|   |           
|   +---config
|   |       app_config.go
|   |       credentials.go
|   |       environment.go
|   |       feature_flags.go
|   |       integration_config.go
|   |       
|   +---domain
|   |   +---ai
|   |   |       model.go
|   |   |       repository.go
|   |   |       service.go
|   |   |       
|   |   +---coordinator
|   |   |       model.go
|   |   |       repository.go
|   |   |       service.go
|   |   |       
|   |   +---design
|   |   |       model.go
|   |   |       repository.go
|   |   |       service.go
|   |   |       
|   |   +---event
|   |   |       model.go
|   |   |       repository.go
|   |   |       service.go
|   |   |       
|   |   +---integration
|   |   |       ai_provider.go
|   |   |       design_provider.go
|   |   |       file_storage_provider.go
|   |   |       notification_provider.go
|   |   |       
|   |   +---quiz
|   |   |   |   model.go
|   |   |   |   repository.go
|   |   |   |   service.go
|   |   |   |   
|   |   |   \---question
|   |   |           base.go
|   |   |           fill_blank.go
|   |   |           mcq.go
|   |   |           true_false.go
|   |   |           
|   |   +---role
|   |   |       model.go
|   |   |       repository.go
|   |   |       service.go
|   |   |       
|   |   \---student
|   |           model.go
|   |           repository.go
|   |           service.go
|   |           
|   +---eventbus
|   |   +---events
|   |   |       quiz_events.go
|   |   |       student_events.go
|   |   |       
|   |   +---publisher
|   |   |       kafka_publisher.go
|   |   |       
|   |   \---subscriber
|   |           kafka_subscriber.go
|   |           
|   +---infrastructure
|   |   +---auth
|   |   |       api_key_manager.go
|   |   |       jwt_provider.go
|   |   |       oauth_client.go
|   |   |       
|   |   +---cache
|   |   |       local_cache.go
|   |   |       redis_cache.go
|   |   |       
|   |   +---database
|   |   |   +---mongodb
|   |   |   |   |   connection.go
|   |   |   |   |   
|   |   |   |   \---repositories
|   |   |   \---postgres
|   |   |       |   connection.go
|   |   |       |   
|   |   |       +---migrations
|   |   |       \---repositories
|   |   |               quiz_repo.go
|   |   |               student_repo.go
|   |   |               
|   |   +---discovery
|   |   |       service_registry.go
|   |   |       
|   |   +---email
|   |   |       smtp_provider.go
|   |   |       template_engine.go
|   |   |       
|   |   +---fallback
|   |   |       notification_fallback.go
|   |   |       storage_fallback.go
|   |   |       
|   |   +---integration
|   |   |   +---canva
|   |   |   |       design_client.go
|   |   |   |       
|   |   |   +---factory
|   |   |   |       ai_factory.go
|   |   |   |       notification_factory.go
|   |   |   |       storage_factory.go
|   |   |   |       
|   |   |   +---google
|   |   |   |       auth.go
|   |   |   |       calendar.go
|   |   |   |       drive.go
|   |   |   |       
|   |   |   +---huggingface
|   |   |   |       client.go
|   |   |   |       model_manager.go
|   |   |   |       
|   |   |   +---onesignal
|   |   |   |       notification_client.go
|   |   |   |       
|   |   |   \---versioning
|   |   |           version_manager.go
|   |   |           
|   |   +---migration
|   |   |       service_switcher.go
|   |   |       
|   |   +---monitoring
|   |   |   |   integration_health.go
|   |   |   |   
|   |   |   \---alerts
|   |   |           service_degradation.go
|   |   |           
|   |   +---offline
|   |   |       offline_queue.go
|   |   |       
|   |   +---quota
|   |   |       limit_tracker.go
|   |   |       throttling_service.go
|   |   |       
|   |   +---sdk
|   |   |       google_sdk_wrapper.go
|   |   |       huggingface_sdk_wrapper.go
|   |   |       
|   |   \---storage
|   |           local_storage.go
|   |           s3_storage.go
|   |           
|   +---security
|   |   \---scanner
|   |           integration_scanner.go
|   |           
|   +---tenant
|   |       integration_config.go
|   |       
|   \---worker
|       +---analytics
|       |       report_worker.go
|       |       
|       +---email
|       |       notification_worker.go
|       |       
|       \---notification
|               push_worker.go
|               
+---migrations
|   +---mongodb
|   \---postgres
|           000001_create_students.down.sql
|           000001_create_students.up.sql
|           
+---pkg
|   +---logger
|   |       logger.go
|   |       
|   +---pagination
|   |       paginator.go
|   |       
|   \---security
|           password.go
|           
+---scripts
|   +---ci
|   |       build.sh
|   |       test.sh
|   |       
|   +---deploy
|   |   |   docker-compose.yml
|   |   |   
|   |   \---kubernetes
|   \---local
|           setup.sh
|           
+---seeds
|   |   seed_runner.go
|   |   
|   +---development
|   |       001_roles.go
|   |       002_admin_users.go
|   |       003_sample_data.go
|   |       
|   +---production
|   |       default_settings.go
|   |       initial_roles.go
|   |       
|   \---testing
|           test_scenarios.go
|           test_users.go
|           
\---test
    +---fixtures
    |       students.json
    |       
    +---integration
    |   |   db_test_helper.go
    |   |   
    |   \---external
    |       |   google_test.go
    |       |   onesignal_test.go
    |       |   
    |       \---mock_services
    |               mock_google_api.go
    |               
    \---mocks
        \---repositories



================================================
File: todo.txt
================================================
1. Add a Token Handeling service like 
// // StudentSession represents an active login session
// type StudentSession struct {
// 	ID           uuid.UUID  `json:"id"`
// 	StudentID    uuid.UUID  `json:"student_id"`
// 	Token        string     `json:"-"` // JWT token - not exposed in JSON
// 	RefreshToken string     `json:"-"` // Refresh token - not exposed in JSON
// 	UserAgent    string     `json:"user_agent"`
// 	IPAddress    string     `json:"ip_address"`
// 	DeviceInfo   string     `json:"device_info,omitempty"`
// 	ExpiresAt    time.Time  `json:"expires_at"`
// 	CreatedAt    time.Time  `json:"created_at"`
// 	RevokedAt    *time.Time `json:"revoked_at,omitempty"`
// }

to manage tokens.


2. Update Error logging and usages and definitions 
and mapping for conversions between layers.

3. Add bulk operations for admin tasks in platform_profile. 
Like CreateProfiles, UpdateProfiles etc. 
Add separate functions for security.

4. Add MFA in login.

5. Add Lock and Unlock mechanisms for multiple failed logins.



================================================
File: cmd/api/main.go
================================================
package main

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"server/internal/api/rest/router"
	"server/internal/config"
	"server/internal/infrastructure/database/postgres"
	"server/pkg/logger"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

func main() {
	// Initialize logger
	log := logger.NewLogger()
	log.Info("Starting TNP RGPV API Server...")

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatal("Failed to load configuration", "error", err)
	}

	// Set Gin mode based on environment
	if cfg.Environment.Production {
		gin.SetMode(gin.ReleaseMode)
	}

	// Connect to PostgreSQL with connection pooling
	db, err := postgres.NewConnection(cfg.Database)
	if err != nil {
		log.Fatal("Failed to connect to PostgreSQL", "error", err)
	}
	
	// Ensure database connection is closed when the application exits
	defer func() {
		db.Close()
		log.Info("PostgreSQL connection pool closed")
	}()

	// Initialize Gin router with recommended middleware
	r := gin.New()
	r.Use(gin.Logger(), gin.Recovery())
	
	// Configure CORS
	r.Use(cors.New(cors.Config{
		AllowOrigins:     cfg.CORS.AllowOrigins,
		AllowMethods:     cfg.CORS.AllowMethods,
		AllowHeaders:     cfg.CORS.AllowHeaders,
		ExposeHeaders:    cfg.CORS.ExposeHeaders,
		AllowCredentials: cfg.CORS.AllowCredentials,
		MaxAge:           cfg.CORS.MaxAge,
	}))

	// Health check endpoint with database connectivity check
	r.GET("/health", func(c *gin.Context) {
		// Check database connectivity
		if err := db.Ping(c.Request.Context()); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"status": "database unavailable", "error": err.Error()})
			return
		}
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	// Register all routes
	router.RegisterRoutes(r, db, log, cfg)

	// Configure server with timeouts
	srv := &http.Server{
		Addr:         ":" + cfg.Server.Port,
		Handler:      r,
		ReadTimeout:  time.Duration(cfg.Server.ReadTimeoutSeconds) * time.Second,
		WriteTimeout: time.Duration(cfg.Server.WriteTimeoutSeconds) * time.Second,
		IdleTimeout:  time.Duration(cfg.Server.IdleTimeoutSeconds) * time.Second,
	}

	// Create a server context for graceful shutdown
	serverCtx, serverStopCtx := context.WithCancel(context.Background())

	// Set up graceful shutdown channel
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Start server in a goroutine
	go func() {
		log.Info("Server starting", "port", cfg.Server.Port)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatal("Server failed to start", "error", err)
		}
		serverStopCtx()
	}()

	// Wait for shutdown signal
	select {
	case <-quit:
		log.Info("Shutdown signal received...")
	case <-serverCtx.Done():
		log.Info("Server stopped...")
	}

	// Create a deadline for shutdown
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), time.Duration(cfg.Server.ShutdownTimeoutSeconds)*time.Second)
	defer shutdownCancel()

	// Shutdown the server
	log.Info("Shutting down server...")
	if err := srv.Shutdown(shutdownCtx); err != nil {
		log.Fatal("Server forced to shutdown", "error", err)
	}

	log.Info("Server exited properly")
}





================================================
File: cmd/migrations/main.go
================================================
package main

import (
	"flag"
	"fmt"
	"os"

	"server/internal/config"
	"server/pkg/logger"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
)

func main() {
	// Command line flags
	var (
		up      = flag.Bool("up", false, "Migrate the DB to the most recent version")
		down    = flag.Bool("down", false, "Roll back the last migration")
		version = flag.Int("version", -1, "Migrate to a specific version")
		steps   = flag.Int("step", 0, "Number of migrations to apply (can be negative for rollback)")
	)
	flag.Parse()

	// Initialize logger
	log := logger.NewLogger()
	log.Info("Starting TNP RGPV Database Migration Tool...")

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatal("Failed to load configuration", "error", err)
	}

	// Construct database URL for migrations
	dbURL := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=%s",
		cfg.Database.UserName,
		cfg.Database.Password,
		cfg.Database.Host,
		cfg.Database.Port,
		cfg.Database.DatabaseName,
		cfg.Database.SSLMode,
	)

	// Initialize migration instance
	m, err := migrate.New("file://migrations/postgres", dbURL)
	if err != nil {
		log.Fatal("Failed to create migration instance", "error", err)
	}
	defer m.Close()

	// Execute migration based on flags
	if *up {
		log.Info("Applying all pending migrations...")
		if err := m.Up(); err != nil && err != migrate.ErrNoChange {
			log.Fatal("Migration failed", "error", err)
		}
		log.Info("Database migrated successfully")
	} else if *down {
		log.Info("Rolling back the last migration...")
		if err := m.Steps(-1); err != nil {
			log.Fatal("Migration rollback failed", "error", err)
		}
		log.Info("Last migration rolled back successfully")
	} else if *version >= 0 {
		log.Info("Migrating to specific version...", "version", *version)
		if err := m.Migrate(uint(*version)); err != nil && err != migrate.ErrNoChange {
			log.Fatal("Migration to version failed", "error", err)
		}
		log.Info("Migration to version completed successfully", "version", *version)
	} else if *steps != 0 {
		log.Info("Applying migration steps...", "steps", *steps)
		if err := m.Steps(*steps); err != nil && err != migrate.ErrNoChange {
			log.Fatal("Migration steps failed", "error", err)
		}
		log.Info("Migration steps completed successfully", "steps", *steps)
	} else {
		// No operation specified
		currentVersion, dirty, err := m.Version()
		if err != nil && err != migrate.ErrNilVersion {
			log.Fatal("Failed to get migration version", "error", err)
		}

		if err == migrate.ErrNilVersion {
			fmt.Println("Database is not yet migrated")
		} else {
			dirtyStatus := ""
			if dirty {
				dirtyStatus = " (DIRTY)"
			}
			fmt.Printf("Current migration version: %d%s\n", currentVersion, dirtyStatus)
		}
		
		fmt.Println("\nUsage:")
		flag.PrintDefaults()
		os.Exit(1)
	}
}


================================================
File: cmd/seed/main.go
================================================
// TODO: Update ad implement
package main

// import (
// 	"flag"
// 	"fmt"
// 	"os"
// 	"strings"

// 	"server/internal/config"
// 	"server/internal/infrastructure/database/postgres"
// 	"server/pkg/logger"
// 	"server/seeds"
// 	"server/seeds/development"
// 	"server/seeds/production"
// 	"server/seeds/testing"
// )

// func main() {
// 	// Command line flags
// 	var (
// 		env     = flag.String("env", "", "Environment to seed (development, testing, production)")
// 		list    = flag.Bool("list", false, "List available seeders")
// 		seeders = flag.String("seeders", "", "Comma-separated list of specific seeders to run")
// 	)
// 	flag.Parse()

// 	// Initialize logger
// 	log := logger.NewLogger()
// 	log.Info("Starting TNP RGPV Database Seeding Tool...")

// 	// Load configuration
// 	cfg, err := config.Load()
// 	if err != nil {
// 		log.Fatal("Failed to load configuration", "error", err)
// 	}

// 	// Connect to PostgreSQL
// 	db, err := postgres.NewConnection(cfg.Database)
// 	if err != nil {
// 		log.Fatal("Failed to connect to PostgreSQL", "error", err)
// 	}

// 	// Ensure database connection is closed when the application exits
// 	defer func() {
// 		db.Close()
// 		log.Info("PostgreSQL connection pool closed")
// 	}()

// 	// Get all available seeders
// 	allSeeders := map[string]seeds.Seeder{
// 		// Development seeders
// 		"dev_roles":        development.NewRolesSeeder(),
// 		"dev_admin_users":  development.NewAdminUsersSeeder(),
// 		"dev_sample_data":  development.NewSampleDataSeeder(),

// 		// Testing seeders
// 		"test_users":      testing.NewTestUsersSeeder(),
// 		"test_scenarios":  testing.NewTestScenariosSeeder(),

// 		// Production seeders
// 		"prod_roles":      production.NewInitialRolesSeeder(),
// 		"prod_settings":   production.NewDefaultSettingsSeeder(),
// 	}

// 	// List seeders if requested
// 	if *list {
// 		fmt.Println("Available seeders:")
// 		fmt.Println("Development seeders:")
// 		for name := range allSeeders {
// 			if strings.HasPrefix(name, "dev_") {
// 				fmt.Printf("  - %s\n", name)
// 			}
// 		}
// 		fmt.Println("Testing seeders:")
// 		for name := range allSeeders {
// 			if strings.HasPrefix(name, "test_") {
// 				fmt.Printf("  - %s\n", name)
// 			}
// 		}
// 		fmt.Println("Production seeders:")
// 		for name := range allSeeders {
// 			if strings.HasPrefix(name, "prod_") {
// 				fmt.Printf("  - %s\n", name)
// 			}
// 		}
// 		os.Exit(0)
// 	}

// 	// Determine which seeders to run
// 	var seedersToRun []seeds.Seeder

// 	if *seeders != "" {
// 		// Run specific seeders
// 		seederNames := strings.Split(*seeders, ",")
// 		for _, name := range seederNames {
// 			name = strings.TrimSpace(name)
// 			seeder, exists := allSeeders[name]
// 			if !exists {
// 				log.Fatal("Seeder not found", "seeder", name)
// 			}
// 			seedersToRun = append(seedersToRun, seeder)
// 		}
// 	} else if *env != "" {
// 		// Run all seeders for a specific environment
// 		prefix := ""
// 		switch *env {
// 		case "development":
// 			prefix = "dev_"
// 		case "testing":
// 			prefix = "test_"
// 		case "production":
// 			prefix = "prod_"
// 		default:
// 			log.Fatal("Invalid environment specified", "env", *env)
// 		}

// 		for name, seeder := range allSeeders {
// 			if strings.HasPrefix(name, prefix) {
// 				seedersToRun = append(seedersToRun, seeder)
// 			}
// 		}
// 	} else {
// 		fmt.Println("Please specify an environment (-env) or specific seeders (-seeders)")
// 		fmt.Println("\nUsage:")
// 		flag.PrintDefaults()
// 		os.Exit(1)
// 	}

// 	// Run the selected seeders
// 	log.Info("Running seeders...", "count", len(seedersToRun))
// 	runner := seeds.NewRunner(db, log)

// 	if err := runner.Run(seedersToRun); err != nil {
// 		log.Fatal("Failed to run seeders", "error", err)
// 	}

// 	log.Info("Database seeding completed successfully")
// }


================================================
File: cmd/worker/main.go
================================================
package main

// import (
// 	"context"
// 	"os"
// 	"os/signal"
// 	"syscall"
// 	"time"

// 	"server/internal/config"
// 	"server/internal/infrastructure/database/postgres"
// 	"server/internal/worker"
// 	"server/pkg/logger"
// )

// func main() {
// 	// Initialize logger
// 	log := logger.NewLogger()
// 	log.Info("Starting TNP RGPV Background Worker...")

// 	// Load configuration
// 	cfg, err := config.Load()
// 	if err != nil {
// 		log.Fatal("Failed to load configuration", "error", err)
// 	}

// 	// Connect to PostgreSQL
// 	db, err := postgres.NewConnection(cfg.Database)
// 	if err != nil {
// 		log.Fatal("Failed to connect to PostgreSQL", "error", err)
// 	}

// 	// Ensure database connection is closed when the application exits
// 	defer func() {
// 		db.Close()
// 		log.Info("PostgreSQL connection pool closed")
// 	}()

// 	// Create context for worker coordination
// 	ctx, cancel := context.WithCancel(context.Background())
// 	defer cancel()

// 	// Initialize and start workers
// 	workers := []worker.Worker{
// 		worker.NewEmailWorker(db, cfg, log),
// 		worker.NewNotificationWorker(db, cfg, log),
// 		worker.NewAnalyticsWorker(db, cfg, log),
// 		// Add additional workers as needed
// 	}

// 	// Start all workers
// 	for _, w := range workers {
// 		go func(worker worker.Worker) {
// 			if err := worker.Start(ctx); err != nil {
// 				log.Error("Worker failed", "worker", worker.Name(), "error", err)
// 			}
// 		}(w)
// 		log.Info("Started worker", "worker", w.Name())
// 	}

// 	// Set up signal handling for graceful shutdown
// 	quit := make(chan os.Signal, 1)
// 	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
// 	<-quit

// 	log.Info("Shutdown signal received, stopping workers...")

// 	// Cancel context to stop all workers
// 	cancel()

// 	// Allow workers time to clean up
// 	time.Sleep(3 * time.Second)

// 	log.Info("All workers stopped successfully")
// }


================================================
File: docs/api/openapi.yaml
================================================



================================================
File: docs/architecture/domain_model.md
================================================



================================================
File: docs/guides/getting_started.md
================================================
# Use SQL directly

## All the validations and assignents to be done in the Service Layer and not in the Infrastructure Layer.


================================================
File: internal/.gitignore
================================================




================================================
File: internal/analytics/cost/service_cost_analyzer.go
================================================
package cost



================================================
File: internal/analytics/usage/integration_usage.go
================================================



================================================
File: internal/api/rest/handler/quiz/attempt_handler.go
================================================
package quiz

import (
	"net/http"
	"strconv"
	"time"

	"server/internal/model"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
)

// AttemptHandler handles HTTP requests related to quiz attempts
type AttemptHandler struct {
	attemptService service.AttemptService
	logger         logger.Logger
}

// NewAttemptHandler creates a new AttemptHandler instance
func NewAttemptHandler(attemptService service.AttemptService, logger logger.Logger) *AttemptHandler {
	return &AttemptHandler{
		attemptService: attemptService,
		logger:         logger,
	}
}

// StartQuizAttempt creates a new quiz attempt
func (h *AttemptHandler) StartQuizAttempt(c *gin.Context) {
	quizID, err := strconv.ParseInt(c.Param("quizId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	attempt := &model.QuizAttempt{
		QuizID:     quizID,
		StudentID:  studentID.(int64),
		StartTime:  time.Now(),
		Status:     "in_progress",
	}

	attemptID, err := h.attemptService.StartQuizAttempt(c.Request.Context(), attempt)
	if err != nil {
		h.logger.Error("Failed to start quiz attempt", "quizID", quizID, "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to start quiz attempt"})
		return
	}

	attempt.ID = attemptID
	c.JSON(http.StatusCreated, attempt)
}

// SubmitQuizAttempt submits answers for a quiz attempt
func (h *AttemptHandler) SubmitQuizAttempt(c *gin.Context) {
	attemptID, err := strconv.ParseInt(c.Param("attemptId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid attempt ID"})
		return
	}

	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	var answers []model.QuizAnswer
	if err := c.ShouldBindJSON(&answers); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Verify that the attempt belongs to the student
	attempt, err := h.attemptService.GetAttemptByID(c.Request.Context(), attemptID)
	if err != nil {
		h.logger.Error("Failed to retrieve attempt", "attemptID", attemptID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to submit quiz attempt"})
		return
	}

	if attempt == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Attempt not found"})
		return
	}

	if attempt.StudentID != studentID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Not authorized to submit this attempt"})
		return
	}

	result, err := h.attemptService.SubmitQuizAttempt(c.Request.Context(), attemptID, answers)
	if err != nil {
		h.logger.Error("Failed to submit quiz attempt", "attemptID", attemptID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to submit quiz attempt"})
		return
	}

	c.JSON(http.StatusOK, result)
}

// GetStudentAttempts retrieves all attempts for a student
func (h *AttemptHandler) GetStudentAttempts(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	attempts, err := h.attemptService.GetStudentAttempts(c.Request.Context(), studentID.(int64))
	if err != nil {
		h.logger.Error("Failed to get student attempts", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve attempts"})
		return
	}

	c.JSON(http.StatusOK, attempts)
}

// GetAttemptDetails retrieves details of a specific attempt
func (h *AttemptHandler) GetAttemptDetails(c *gin.Context) {
	attemptID, err := strconv.ParseInt(c.Param("attemptId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid attempt ID"})
		return
	}

	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	details, err := h.attemptService.GetAttemptDetails(c.Request.Context(), attemptID)
	if err != nil {
		h.logger.Error("Failed to get attempt details", "attemptID", attemptID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve attempt details"})
		return
	}

	if details == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Attempt not found"})
		return
	}

	if details.StudentID != studentID.(int64) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Not authorized to view this attempt"})
		return
	}

	c.JSON(http.StatusOK, details)
}


================================================
File: internal/api/rest/handler/quiz/quiz_handler.go
================================================
package quiz

import (
	"net/http"
	"strconv"

	"server/internal/model"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
)

// QuizHandler handles HTTP requests related to quizzes
type QuizHandler struct {
	quizService service.QuizService
	logger      logger.Logger
}

// NewQuizHandler creates a new QuizHandler instance
func NewQuizHandler(quizService service.QuizService, logger logger.Logger) *QuizHandler {
	return &QuizHandler{
		quizService: quizService,
		logger:      logger,
	}
}

// GetAllQuizzes retrieves all quizzes
func (h *QuizHandler) GetAllQuizzes(c *gin.Context) {
	quizzes, err := h.quizService.GetAllQuizzes(c.Request.Context())
	if err != nil {
		h.logger.Error("Failed to get quizzes", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve quizzes"})
		return
	}

	c.JSON(http.StatusOK, quizzes)
}

// GetQuizByID retrieves a quiz by ID
func (h *QuizHandler) GetQuizByID(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	quiz, err := h.quizService.GetQuizByID(c.Request.Context(), id)
	if err != nil {
		h.logger.Error("Failed to get quiz", "id", id, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve quiz"})
		return
	}

	if quiz == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Quiz not found"})
		return
	}

	c.JSON(http.StatusOK, quiz)
}

// CreateQuiz creates a new quiz
func (h *QuizHandler) CreateQuiz(c *gin.Context) {
	var quiz model.Quiz
	if err := c.ShouldBindJSON(&quiz); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	id, err := h.quizService.CreateQuiz(c.Request.Context(), &quiz)
	if err != nil {
		h.logger.Error("Failed to create quiz", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create quiz"})
		return
	}

	quiz.ID = id
	c.JSON(http.StatusCreated, quiz)
}

// UpdateQuiz updates an existing quiz
func (h *QuizHandler) UpdateQuiz(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	var quiz model.Quiz
	if err := c.ShouldBindJSON(&quiz); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	quiz.ID = id
	if err := h.quizService.UpdateQuiz(c.Request.Context(), &quiz); err != nil {
		h.logger.Error("Failed to update quiz", "id", id, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update quiz"})
		return
	}

	c.JSON(http.StatusOK, quiz)
}

// DeleteQuiz deletes a quiz
func (h *QuizHandler) DeleteQuiz(c *gin.Context) {
	id, err := strconv.ParseInt(c.Param("id"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	if err := h.quizService.DeleteQuiz(c.Request.Context(), id); err != nil {
		h.logger.Error("Failed to delete quiz", "id", id, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete quiz"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Quiz deleted successfully"})
}

// GetQuizQuestions retrieves all questions for a quiz
func (h *QuizHandler) GetQuizQuestions(c *gin.Context) {
	quizID, err := strconv.ParseInt(c.Param("quizId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	questions, err := h.quizService.GetQuizQuestions(c.Request.Context(), quizID)
	if err != nil {
		h.logger.Error("Failed to get quiz questions", "quizID", quizID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve questions"})
		return
	}

	c.JSON(http.StatusOK, questions)
}

// AddQuizQuestion adds a question to a quiz
func (h *QuizHandler) AddQuizQuestion(c *gin.Context) {
	quizID, err := strconv.ParseInt(c.Param("quizId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	var question model.Question
	if err := c.ShouldBindJSON(&question); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	question.QuizID = quizID
	id, err := h.quizService.AddQuizQuestion(c.Request.Context(), &question)
	if err != nil {
		h.logger.Error("Failed to add question", "quizID", quizID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add question"})
		return
	}

	question.ID = id
	c.JSON(http.StatusCreated, question)
}

// UpdateQuizQuestion updates a question
func (h *QuizHandler) UpdateQuizQuestion(c *gin.Context) {
	quizID, err := strconv.ParseInt(c.Param("quizId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid quiz ID"})
		return
	}

	questionID, err := strconv.ParseInt(c.Param("questionId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
		return
	}

	var question model.Question
	if err := c.ShouldBindJSON(&question); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	question.ID = questionID
	question.QuizID = quizID
	if err := h.quizService.UpdateQuizQuestion(c.Request.Context(), &question); err != nil {
		h.logger.Error("Failed to update question", "questionID", questionID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update question"})
		return
	}

	c.JSON(http.StatusOK, question)
}

// DeleteQuizQuestion deletes a question
func (h *QuizHandler) DeleteQuizQuestion(c *gin.Context) {
	questionID, err := strconv.ParseInt(c.Param("questionId"), 10, 64)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid question ID"})
		return
	}

	if err := h.quizService.DeleteQuizQuestion(c.Request.Context(), questionID); err != nil {
		h.logger.Error("Failed to delete question", "questionID", questionID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete question"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Question deleted successfully"})
}


================================================
File: internal/api/rest/handler/student/auth_handler.go
================================================
package student

import (
	"net/http"

	"server/internal/model"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
)

// AuthHandler handles HTTP requests related to student authentication
type AuthHandler struct {
	authService service.AuthService
	logger      logger.Logger
}

// NewAuthHandler creates a new AuthHandler instance
func NewAuthHandler(authService service.AuthService, logger logger.Logger) *AuthHandler {
	return &AuthHandler{
		authService: authService,
		logger:      logger,
	}
}

// Register registers a new student
func (h *AuthHandler) Register(c *gin.Context) {
	var student model.Student
	if err := c.ShouldBindJSON(&student); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.authService.Register(c.Request.Context(), &student); err != nil {
		h.logger.Error("Failed to register student", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to register"})
		return
	}

	// Remove password before returning
	student.Password = ""
	c.JSON(http.StatusCreated, student)
}

// Login authenticates a student
func (h *AuthHandler) Login(c *gin.Context) {
	var credentials struct {
		Email    string `json:"email" binding:"required,email"`
		Password string `json:"password" binding:"required"`
	}

	if err := c.ShouldBindJSON(&credentials); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	token, student, err := h.authService.Login(c.Request.Context(), credentials.Email, credentials.Password)
	if err != nil {
		h.logger.Error("Failed to login", "email", credentials.Email, "error", err)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"token":  token,
		"student": gin.H{
			"id":    student.ID,
			"name":  student.Name,
			"email": student.Email,
		},
	})
}

// VerifyEmail verifies a student's email
func (h *AuthHandler) VerifyEmail(c *gin.Context) {
	token := c.Query("token")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Verification token is required"})
		return
	}

	if err := h.authService.VerifyEmail(c.Request.Context(), token); err != nil {
		h.logger.Error("Failed to verify email", "token", token, "error", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid or expired verification token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Email verified successfully"})
}

// ForgotPassword initiates the password reset process
func (h *AuthHandler) ForgotPassword(c *gin.Context) {
	var request struct {
		Email string `json:"email" binding:"required,email"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.authService.ForgotPassword(c.Request.Context(), request.Email); err != nil {
		h.logger.Error("Failed to process forgot password", "email", request.Email, "error", err)
		// Don't reveal if the email exists or not
		c.JSON(http.StatusOK, gin.H{"message": "If your email is registered, you will receive a password reset link"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "If your email is registered, you will receive a password reset link"})
}

// ResetPassword resets a student's password
func (h *AuthHandler) ResetPassword(c *gin.Context) {
	var request struct {
		Token           string `json:"token" binding:"required"`
		NewPassword     string `json:"new_password" binding:"required,min=8"`
		ConfirmPassword string `json:"confirm_password" binding:"required,eqfield=NewPassword"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.authService.ResetPassword(c.Request.Context(), request.Token, request.NewPassword); err != nil {
		h.logger.Error("Failed to reset password", "error", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid or expired reset token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password reset successfully"})
}

// Logout logs out a student
func (h *AuthHandler) Logout(c *gin.Context) {
	token := c.GetHeader("Authorization")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Authorization token is required"})
		return
	}

	// Remove "Bearer " prefix if present
	if len(token) > 7 && token[:7] == "Bearer " {
		token = token[7:]
	}

	if err := h.authService.Logout(c.Request.Context(), token); err != nil {
		h.logger.Error("Failed to logout", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to logout"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})
}


================================================
File: internal/api/rest/handler/student/profile_handler.go
================================================
package student

import (
	"net/http"

	"server/internal/model"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
)

// ProfileHandler handles HTTP requests related to student profiles
type ProfileHandler struct {
	profileService service.ProfileService
	logger         logger.Logger
}

// NewProfileHandler creates a new ProfileHandler instance
func NewProfileHandler(profileService service.ProfileService, logger logger.Logger) *ProfileHandler {
	return &ProfileHandler{
		profileService: profileService,
		logger:         logger,
	}
}

// GetProfile retrieves a student's profile
func (h *ProfileHandler) GetProfile(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	profile, err := h.profileService.GetProfile(c.Request.Context(), studentID.(int64))
	if err != nil {
		h.logger.Error("Failed to get profile", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve profile"})
		return
	}

	if profile == nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Profile not found"})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// UpdateProfile updates a student's profile
func (h *ProfileHandler) UpdateProfile(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	var profile model.StudentProfile
	if err := c.ShouldBindJSON(&profile); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	profile.StudentID = studentID.(int64)
	if err := h.profileService.UpdateProfile(c.Request.Context(), &profile); err != nil {
		h.logger.Error("Failed to update profile", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile"})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// ChangePassword changes a student's password
func (h *ProfileHandler) ChangePassword(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	var request struct {
		CurrentPassword string `json:"current_password" binding:"required"`
		NewPassword     string `json:"new_password" binding:"required,min=8"`
		ConfirmPassword string `json:"confirm_password" binding:"required,eqfield=NewPassword"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := h.profileService.ChangePassword(
		c.Request.Context(),
		studentID.(int64),
		request.CurrentPassword,
		request.NewPassword,
	); err != nil {
		h.logger.Error("Failed to change password", "studentID", studentID, "error", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to change password"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Password changed successfully"})
}

// UploadProfilePicture uploads a profile picture
func (h *ProfileHandler) UploadProfilePicture(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	file, err := c.FormFile("profile_picture")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Failed to get uploaded file"})
		return
	}

	// Validate file size (max 5MB)
	if file.Size > 5*1024*1024 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File size exceeds 5MB limit"})
		return
	}

	// Open the uploaded file
	src, err := file.Open()
	if err != nil {
		h.logger.Error("Failed to open uploaded file", "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process uploaded file"})
		return
	}
	defer src.Close()

	// Upload the file
	picturePath, err := h.profileService.UploadProfilePicture(c.Request.Context(), studentID.(int64), src, file.Filename)
	if err != nil {
		h.logger.Error("Failed to upload profile picture", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload profile picture"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Profile picture uploaded successfully",
		"path":    picturePath,
	})
}

// GetAcademicRecords retrieves a student's academic records
func (h *ProfileHandler) GetAcademicRecords(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	records, err := h.profileService.GetAcademicRecords(c.Request.Context(), studentID.(int64))
	if err != nil {
		h.logger.Error("Failed to get academic records", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve academic records"})
		return
	}

	c.JSON(http.StatusOK, records)
}

// GetQuizHistory retrieves a student's quiz history
func (h *ProfileHandler) GetQuizHistory(c *gin.Context) {
	studentID, exists := c.Get("studentID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Not authenticated"})
		return
	}

	history, err := h.profileService.GetQuizHistory(c.Request.Context(), studentID.(int64))
	if err != nil {
		h.logger.Error("Failed to get quiz history", "studentID", studentID, "error", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve quiz history"})
		return
	}

	c.JSON(http.StatusOK, history)
}


================================================
File: internal/api/rest/middleware/auth.go
================================================



================================================
File: internal/api/rest/middleware/logging.go
================================================



================================================
File: internal/api/rest/middleware/rate_limit.go
================================================



================================================
File: internal/api/rest/router/quiz_routes.go
================================================
package router

import (
	"server/internal/api/rest/handlers"
	"server/internal/config"
	"server/internal/repository"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
	"github.com/jmoiron/sqlx"
)

// RegisterQuizRoutes sets up all quiz-related routes
func RegisterQuizRoutes(r *gin.RouterGroup, db *sqlx.DB, log *logger.Logger, cfg *config.Config) {
	// Create repositories
	quizRepo := repository.NewQuizRepository(db)
	
	// Create services
	quizService := service.NewQuizService(quizRepo, log)
	
	// Create handlers
	quizHandler := handlers.NewQuizHandler(quizService, log)
	
	// Define routes
	quizzes := r.Group("/quizzes")
	{
		quizzes.GET("", quizHandler.GetAllQuizzes)
		quizzes.GET("/:id", quizHandler.GetQuizByID)
		quizzes.POST("", quizHandler.CreateQuiz)
		quizzes.PUT("/:id", quizHandler.UpdateQuiz)
		quizzes.DELETE("/:id", quizHandler.DeleteQuiz)
		
		// Questions routes
		questions := quizzes.Group("/:quizId/questions")
		{
			questions.GET("", quizHandler.GetQuizQuestions)
			questions.POST("", quizHandler.AddQuizQuestion)
			questions.PUT("/:questionId", quizHandler.UpdateQuizQuestion)
			questions.DELETE("/:questionId", quizHandler.DeleteQuizQuestion)
		}
		
		// Add more quiz-related routes as needed
	}
}


================================================
File: internal/api/rest/router/router.go
================================================
package router

import (
	"server/internal/config"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
	"github.com/jmoiron/sqlx"
)

// RegisterRoutes sets up all API routes
func RegisterRoutes(r *gin.Engine, db *sqlx.DB, log *logger.Logger, cfg *config.Config) {
	// API versioning
	v1 := r.Group("/api/v1")

	// Register all route groups
	RegisterStudentRoutes(v1, db, log, cfg)
	RegisterQuizRoutes(v1, db, log, cfg)
	
	// Add more route groups as needed
}


================================================
File: internal/api/rest/router/student_routes.go
================================================
package router

import (
	"server/internal/api/rest/handlers"
	"server/internal/config"
	"server/internal/repository"
	"server/internal/service"
	"server/pkg/logger"

	"github.com/gin-gonic/gin"
	"github.com/jmoiron/sqlx"
)

// RegisterStudentRoutes sets up all student-related routes
func RegisterStudentRoutes(r *gin.RouterGroup, db *sqlx.DB, log *logger.Logger, cfg *config.Config) {
	// Create repositories
	studentRepo := repository.NewStudentRepository(db)
	
	// Create services
	studentService := service.NewStudentService(studentRepo, log)
	
	// Create handlers
	studentHandler := handlers.NewStudentHandler(studentService, log)
	
	// Define routes
	students := r.Group("/students")
	{
		students.GET("", studentHandler.GetAllStudents)
		students.GET("/:id", studentHandler.GetStudentByID)
		students.POST("", studentHandler.CreateStudent)
		students.PUT("/:id", studentHandler.UpdateStudent)
		students.DELETE("/:id", studentHandler.DeleteStudent)
		
		// Add more student-related routes as needed
	}
}

// package router

// import (
// 	"server/internal/api/rest/handlers/student"
// 	"server/internal/config"
// 	"server/internal/repository"
// 	"server/internal/service"
// 	"server/internal/middleware"
// 	"server/pkg/logger"

// 	"github.com/gin-gonic/gin"
// 	"github.com/jmoiron/sqlx"
// )

// // RegisterStudentRoutes sets up all student-related routes
// func RegisterStudentRoutes(r *gin.RouterGroup, db *sqlx.DB, log logger.Logger, cfg *config.Config) {
// 	// Create repositories
// 	studentRepo := repository.NewStudentRepository(db)
// 	profileRepo := repository.NewProfileRepository(db)
	
// 	// Create services
// 	authService := service.NewAuthService(studentRepo, log, cfg)
// 	profileService := service.NewProfileService(profileRepo, studentRepo, log, cfg)
	
// 	// Create handlers
// 	authHandler := student.NewAuthHandler(authService, log)
// 	profileHandler := student.NewProfileHandler(profileService, log)
	
// 	// Auth routes (no authentication required)
// 	auth := r.Group("/auth")
// 	{
// 		auth.POST("/register", authHandler.Register)
// 		auth.POST("/login", authHandler.Login)
// 		auth.GET("/verify-email", authHandler.VerifyEmail)
// 		auth.POST("/forgot-password", authHandler.ForgotPassword)
// 		auth.POST("/reset-password", authHandler.ResetPassword)
// 	}
	
// 	// Student profile routes (authentication required)
// 	students := r.Group("/students")
// 	students.Use(middleware.Authenticate(authService))
// 	{
// 		students.GET("/profile", profileHandler.GetProfile)
// 		students.PUT("/profile", profileHandler.UpdateProfile)
// 		students.POST("/change-password", profileHandler.ChangePassword)
// 		students.POST("/profile-picture", profileHandler.UploadProfilePicture)
// 		students.GET("/academic-records", profileHandler.GetAcademicRecords)
// 		students.GET("/quiz-history", profileHandler.GetQuizHistory)
// 		students.POST("/logout", authHandler.Logout)
// 	}
// }


================================================
File: internal/api/webhook/canva_webhook.go
================================================



================================================
File: internal/api/webhook/google_webhook.go
================================================



================================================
File: internal/api/webhook/onesignal_webhook.go
================================================



================================================
File: internal/common/errors/domain_errors.go
================================================
package errors

import (
	"errors"
	"fmt"
)

// Domain-specific error types to streamline error handling

// ErrorType represents the type of an error
type ErrorType string

// Error types
const (
	// NotFound errors
	NotFoundError ErrorType = "NOT_FOUND"

	// Validation errors
	ValidationError ErrorType = "VALIDATION"

	// Authorization errors
	UnauthorizedError ErrorType = "UNAUTHORIZED"
	ForbiddenError    ErrorType = "FORBIDDEN"

	// Conflict errors
	ConflictError ErrorType = "CONFLICT"

	// System errors
	DatabaseError    ErrorType = "DATABASE"
	NetworkError     ErrorType = "NETWORK"
	IntegrationError ErrorType = "INTEGRATION"

	// Input errors
	BadInputError ErrorType = "BAD_INPUT"

	// Business logic errors
	BusinessError ErrorType = "BUSINESS"

	// Unknown errors
	UnknownError ErrorType = "UNKNOWN"
)

// DomainError represents a structured error in the system
type DomainError struct {
	Type    ErrorType
	Message string
	Code    string
	Details map[string]interface{}
	Cause   error
}

// Implement the error interface
func (e *DomainError) Error() string {
	if e.Cause != nil {
		return fmt.Sprintf("%s: %s (code: %s, cause: %v)", e.Type, e.Message, e.Code, e.Cause)
	}
	return fmt.Sprintf("%s: %s (code: %s)", e.Type, e.Message, e.Code)
}

// Unwrap returns the underlying cause of the error
func (e *DomainError) Unwrap() error {
	return e.Cause
}

// Generic error constructors
func NewDomainError(message string, errorType ErrorType, code string, details map[string]interface{}, cause error) *DomainError {
	return &DomainError{
		Type:    errorType,
		Message: message,
		Code:    code,
		Details: details,
		Cause:   cause,
	}
}

// Specific error constructors
func NewNotFoundError(entity string, id any) *DomainError {
	return NewDomainError(
		fmt.Sprintf("%s with ID %v not found", entity, id),
		NotFoundError,
		"ENTITY_NOT_FOUND",
		map[string]any{"entity": entity, "id": id},
		nil,
	)
}

func NewValidationError(message string, details map[string]any) *DomainError {
	return NewDomainError(
		message,
		ValidationError,
		"VALIDATION_FAILED",
		details,
		nil,
	)
}

func NewUnauthorizedError(message string) *DomainError {
	if message == "" {
		message = "Authorization required"
	}
	return NewDomainError(
		message,
		UnauthorizedError,
		"UNAUTHORIZED",
		nil,
		nil,
	)
}

func NewForbiddenError(message string) *DomainError {
	if message == "" {
		message = "Access forbidden"
	}
	return NewDomainError(
		message,
		ForbiddenError,
		"FORBIDDEN",
		nil,
		nil,
	)
}

func NewConflictError(entity string, details map[string]any) *DomainError {
	return NewDomainError(
		fmt.Sprintf("Conflict with existing %s", entity),
		ConflictError,
		"ENTITY_CONFLICT",
		details,
		nil,
	)
}

func NewDatabaseError(operation string, cause error) *DomainError {
	return NewDomainError(
		fmt.Sprintf("Database error during %s", operation),
		DatabaseError,
		"DATABASE_ERROR",
		map[string]interface{}{"operation": operation},
		cause,
	)
}

func NewNetworkError(operation string, cause error) *DomainError {
	return NewDomainError(
		fmt.Sprintf("Network error during %s", operation),
		NetworkError,
		"NETWORK_ERROR",
		map[string]interface{}{"operation": operation},
		cause,
	)
}

func NewIntegrationError(integration string, operation string, cause error) *DomainError {
	return NewDomainError(
		fmt.Sprintf("Error with %s integration during %s", integration, operation),
		IntegrationError,
		"INTEGRATION_ERROR",
		map[string]interface{}{"integration": integration, "operation": operation},
		cause,
	)
}

func NewBadInputError(message string, details map[string]any) *DomainError {
	return NewDomainError(
		message,
		BadInputError,
		"BAD_INPUT",
		details,
		nil,
	)
}

func NewBusinessError(code string, message string, details map[string]any) *DomainError {
	return NewDomainError(
		message,
		BusinessError,
		code,
		details,
		nil,
	)
}

func NewUnknownError(cause error) *DomainError {
	return NewDomainError(
		"An unknown error occurred",
		UnknownError,
		"UNKNOWN_ERROR",
		nil,
		cause,
	)
}

// Utility functions
func IsDomainError(err error) bool {
	var de *DomainError
	return errors.As(err, &de)
}

func ErrorTypeOf(err error) ErrorType {
	var de *DomainError
	if errors.As(err, &de) {
		return de.Type
	}
	return UnknownError
}

func IsNotFoundErrorDomain(err error) bool {
	return ErrorTypeOf(err) == NotFoundError
}

func IsValidationError(err error) bool {
	return ErrorTypeOf(err) == ValidationError
}

func IsAuthorizationError(err error) bool {
	errType := ErrorTypeOf(err)
	return errType == UnauthorizedError || errType == ForbiddenError
}

func IsConflictError(err error) bool {
	return ErrorTypeOf(err) == ConflictError
}



================================================
File: internal/common/errors/http_errors.go
================================================
package errors

import (
	"errors"
	"fmt"
	"net/http"
	"runtime/debug"

	"github.com/gin-gonic/gin"
	"github.com/go-playground/validator/v10"
)

// APIError represents an error response from the API
type APIError struct {
	Status  int                    `json:"-"`
	Code    string                 `json:"code"`
	Message string                 `json:"message"`
	Details map[string]interface{} `json:"details,omitempty"`
}

// Error implements the error interface
func (e *APIError) Error() string {
	return fmt.Sprintf("API Error %d: %s - %s", e.Status, e.Code, e.Message)
}

// RespondWithError writes the error to the Gin context response
func (e *APIError) RespondWithError(c *gin.Context) {
	c.JSON(e.Status, e)
}

// NewAPIError creates a new API error
func NewAPIError(status int, code string, message string, details map[string]interface{}) *APIError {
	return &APIError{
		Status:  status,
		Code:    code,
		Message: message,
		Details: details,
	}
}

// Common error creators
func BadRequest(message string, details map[string]interface{}) *APIError {
	return NewAPIError(http.StatusBadRequest, "bad_request", message, details)
}

func Unauthorized(message string) *APIError {
	if message == "" {
		message = "Authentication required"
	}
	return NewAPIError(http.StatusUnauthorized, "unauthorized", message, nil)
}

func Forbidden(message string) *APIError {
	if message == "" {
		message = "You don't have permission to access this resource"
	}
	return NewAPIError(http.StatusForbidden, "forbidden", message, nil)
}

func NotFound(resource string) *APIError {
	message := "Resource not found"
	if resource != "" {
		message = fmt.Sprintf("%s not found", resource)
	}
	return NewAPIError(http.StatusNotFound, "not_found", message, nil)
}

func InternalServerError(err error) *APIError {
	return NewAPIError(http.StatusInternalServerError, "internal_server_error", "Internal server error", map[string]interface{}{
		"error": err.Error(),
	})
}

func Conflict(message string, details map[string]interface{}) *APIError {
	return NewAPIError(http.StatusConflict, "conflict", message, details)
}

// HandleValidationErrors converts validator errors into API errors
func HandleValidationErrors(err error) *APIError {
	var validationErrors validator.ValidationErrors
	if errors.As(err, &validationErrors) {
		details := make(map[string]interface{})
		for _, fieldError := range validationErrors {
			details[fieldError.Field()] = map[string]interface{}{
				"tag":     fieldError.Tag(),
				"value":   fieldError.Value(),
				"message": getValidationErrorMessage(fieldError),
			}
		}
		return BadRequest("Validation failed", details)
	}
	return BadRequest(err.Error(), nil)
}

// getValidationErrorMessage returns a human-readable message for validation errors
func getValidationErrorMessage(fieldError validator.FieldError) string {
	switch fieldError.Tag() {
	case "required":
		return "This field is required"
	case "email":
		return "Invalid email format"
	case "min":
		return fmt.Sprintf("Should be at least %s", fieldError.Param())
	case "max":
		return fmt.Sprintf("Should be at most %s", fieldError.Param())
	case "url":
		return "Invalid URL format"
	default:
		return fmt.Sprintf("Failed validation on %s", fieldError.Tag())
	}
}

// ErrorHandler middleware for uniform error handling in Gin
func ErrorHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if r := recover(); r != nil {
				// Log the error and stack trace
				stackTrace := string(debug.Stack())
				fmt.Printf("PANIC: %v\nStack: %s\n", r, stackTrace)

				// Create an API error
				apiErr := NewAPIError(
					http.StatusInternalServerError,
					"internal_server_error",
					"An unexpected error occurred",
					nil, // Don't expose internal details in production
				)
				apiErr.RespondWithError(c)
				c.Abort()
			}
		}()
		c.Next()
	}
}

// HandleDBError handles database-related errors
func HandleDBError(err error) *APIError {
	// Here you could have specific handling for pgx errors
	// For example check for unique constraint violations
	if err != nil {
		// This is where you'd check for specific pgx error types
		// Example: if pgerrcode.IsIntegrityConstraintViolation(err)

		// For now, a simple fallback
		return InternalServerError(err)
	}
	return nil
}

// IsNotFoundError checks if an error is a "not found" error
func IsNotFoundErrorAPI(err error) bool {
	var apiErr *APIError
	if errors.As(err, &apiErr) {
		return apiErr.Status == http.StatusNotFound
	}
	return false
}

// RespondWithError is a helper to respond with an error
func RespondWithError(c *gin.Context, err error) {
	var apiErr *APIError
	if errors.As(err, &apiErr) {
		apiErr.RespondWithError(c)
		return
	}

	// If it's not an APIError, create an internal server error
	InternalServerError(err).RespondWithError(c)
}



================================================
File: internal/common/errors/infrastructure_errors.go
================================================
package errors

// import (
// 	"fmt"
// )

// // InfrastructureError represents a low-level error
// type InfrastructureError struct {
// 	Message string
// 	Cause   error
// }

// // Implement the error interface
// func (e *InfrastructureError) Error() string {
// 	if e.Cause != nil {
// 		return fmt.Sprintf("%s: %v", e.Message, e.Cause)
// 	}
// 	return e.Message
// }

// // Unwrap returns the underlying cause of the error
// func (e *InfrastructureError) Unwrap() error {
// 	return e.Cause
// }

// // Infrastructure-specific error constructors
// func NewDBConnectionErrorInfra(cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: "Failed to establish database connection",
// 		Cause:   cause,
// 	}
// }

// func NewDBTransactionErrorInfra(cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: "Database transaction failed",
// 		Cause:   cause,
// 	}
// }

// func NewDBQueryErrorInfra(query string, cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: fmt.Sprintf("Error executing query: %s", query),
// 		Cause:   cause,
// 	}
// }

// func NewCacheErrorInfra(operation string, cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: fmt.Sprintf("Cache error during %s", operation),
// 		Cause:   cause,
// 	}
// }

// func NewNetworkErrorInfra(endpoint string, cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: fmt.Sprintf("Network error while calling %s", endpoint),
// 		Cause:   cause,
// 	}
// }

// func NewFileErrorInfra(operation string, cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: fmt.Sprintf("File system error during %s", operation),
// 		Cause:   cause,
// 	}
// }

// func NewIntegrationErrorInfra(service string, cause error) *InfrastructureError {
// 	return &InfrastructureError{
// 		Message: fmt.Sprintf("Error with external integration: %s", service),
// 		Cause:   cause,
// 	}
// }



================================================
File: internal/common/utils/pagination.go
================================================
package utils

import (
	"math"
	"net/http"
	"net/url"
	"strconv"
)

// PaginationParams holds pagination information
type PaginationParams struct {
	Page       int   `json:"page"`
	PageSize   int   `json:"pageSize"`
	TotalItems int64 `json:"totalItems"`
	TotalPages int   `json:"totalPages"`
}

// PagedResult represents a paginated result set
type PagedResult struct {
	Items      interface{}      `json:"items"`
	Pagination PaginationParams `json:"pagination"`
}

// Pagination constants
const (
	DefaultPage     = 1
	DefaultPageSize = 20
	MaxPageSize     = 100
)

// ExtractPaginationParams extracts pagination parameters from the request query
func ExtractPaginationParams(r *http.Request) PaginationParams {
	query := r.URL.Query()

	page := parseIntParam(query, "page", DefaultPage)
	if page < 1 {
		page = DefaultPage
	}

	pageSize := parseIntParam(query, "pageSize", DefaultPageSize)
	if pageSize < 1 {
		pageSize = DefaultPageSize
	}
	if pageSize > MaxPageSize {
		pageSize = MaxPageSize
	}

	return PaginationParams{
		Page:     page,
		PageSize: pageSize,
	}
}

// parseIntParam parses an integer parameter from query parameters
func parseIntParam(query url.Values, key string, defaultValue int) int {
	strValue := query.Get(key)
	if strValue == "" {
		return defaultValue
	}

	value, err := strconv.Atoi(strValue)
	if err != nil {
		return defaultValue
	}

	return value
}

// CalculatePagination calculates pagination values
func CalculatePagination(totalItems int64, params PaginationParams) PaginationParams {
	totalPages := int(math.Ceil(float64(totalItems) / float64(params.PageSize)))

	return PaginationParams{
		Page:       params.Page,
		PageSize:   params.PageSize,
		TotalItems: totalItems,
		TotalPages: totalPages,
	}
}

// ApplyPagination applies pagination to SQL queries
func ApplyPagination(query string, params PaginationParams) (string, int, int) {
	offset := (params.Page - 1) * params.PageSize
	limit := params.PageSize

	return query + " LIMIT ? OFFSET ?", limit, offset
}

// NewPagedResult creates a new paged result
func NewPagedResult(items interface{}, totalItems int64, params PaginationParams) PagedResult {
	pagination := CalculatePagination(totalItems, params)

	return PagedResult{
		Items:      items,
		Pagination: pagination,
	}
}

// BuildPaginationLinks builds pagination links for HATEOAS
func BuildPaginationLinks(baseURL string, pagination PaginationParams) map[string]string {
	links := make(map[string]string)

	// Parse base URL
	u, err := url.Parse(baseURL)
	if err != nil {
		return links
	}

	// Get query parameters
	query := u.Query()

	// Self link
	query.Set("page", strconv.Itoa(pagination.Page))
	query.Set("pageSize", strconv.Itoa(pagination.PageSize))
	u.RawQuery = query.Encode()
	links["self"] = u.String()

	// First page link
	query.Set("page", "1")
	u.RawQuery = query.Encode()
	links["first"] = u.String()

	// Last page link
	query.Set("page", strconv.Itoa(pagination.TotalPages))
	u.RawQuery = query.Encode()
	links["last"] = u.String()

	// Previous page link (if not on first page)
	if pagination.Page > 1 {
		query.Set("page", strconv.Itoa(pagination.Page-1))
		u.RawQuery = query.Encode()
		links["prev"] = u.String()
	}

	// Next page link (if not on last page)
	if pagination.Page < pagination.TotalPages {
		query.Set("page", strconv.Itoa(pagination.Page+1))
		u.RawQuery = query.Encode()
		links["next"] = u.String()
	}

	return links
}

// HasNextPage checks if there is a next page
func HasNextPage(pagination PaginationParams) bool {
	return pagination.Page < pagination.TotalPages
}

// HasPrevPage checks if there is a previous page
func HasPrevPage(pagination PaginationParams) bool {
	return pagination.Page > 1
}

// GetSkip calculates the number of items to skip for MongoDB/NoSQL
func GetSkip(pagination PaginationParams) int64 {
	return int64((pagination.Page - 1) * pagination.PageSize)
}

// GetLimit returns the page size as limit
func GetLimit(pagination PaginationParams) int64 {
	return int64(pagination.PageSize)
}



================================================
File: internal/common/utils/security.go
================================================
package utils

import (
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/argon2"
)

// SecurityConstants defines security-related constants
const (
	// Token related
	TokenExpiryTime = 24 * time.Hour

	// CSRF related
	CSRFTokenLength = 32
	CSRFCookieName  = "csrf_token"
	CSRFHeaderName  = "X-CSRF-Token"

	// Password hashing related
	ArgonTime    = 1
	ArgonMemory  = 64 * 1024
	ArgonThreads = 4
	ArgonKeyLen  = 32
	ArgonSaltLen = 16
)

// ArgonParams represents the parameters used for Argon2 hashing
type ArgonParams struct {
	Memory      uint32
	Iterations  uint32
	Parallelism uint8
	SaltLength  uint32
	KeyLength   uint32
}

// DefaultArgonParams returns the default parameters for Argon2 hashing
func DefaultArgonParams() *ArgonParams {
	return &ArgonParams{
		Memory:      ArgonMemory,
		Iterations:  ArgonTime,
		Parallelism: ArgonThreads,
		SaltLength:  ArgonSaltLen,
		KeyLength:   ArgonKeyLen,
	}
}

// GenerateRandomBytes generates cryptographically secure random bytes
func GenerateRandomBytes(length int) ([]byte, error) {
	bytes := make([]byte, length)
	_, err := rand.Read(bytes)
	if err != nil {
		return nil, err
	}

	return bytes, nil
}

// GenerateToken generates a secure random token as a hex string
func GenerateToken(length int) (string, error) {
	bytes, err := GenerateRandomBytes(length)
	if err != nil {
		return "", err
	}

	return hex.EncodeToString(bytes), nil
}

// GenerateCSRFToken generates a new CSRF token
func GenerateCSRFToken() (string, error) {
	return GenerateToken(CSRFTokenLength)
}

// SetCSRFToken sets a CSRF token in both context and cookie
func SetCSRFToken(c *gin.Context) (string, error) {
	token, err := GenerateCSRFToken()
	if err != nil {
		return "", err
	}

	// Store token in context for template rendering
	c.Set("csrf_token", token)

	// Set cookie
	c.SetCookie(
		CSRFCookieName,
		token,
		int(TokenExpiryTime.Seconds()),
		"/",
		"",
		true, // Secure
		true, // HTTP only
	)

	return token, nil
}

// ValidateCSRFToken validates a CSRF token against the one stored in cookie
func ValidateCSRFToken(c *gin.Context) bool {
	// Get token from cookie
	cookieToken, err := c.Cookie(CSRFCookieName)
	if err != nil {
		return false
	}

	// Get token from header
	headerToken := c.GetHeader(CSRFHeaderName)
	if headerToken == "" {
		// If not in header, try from form
		headerToken = c.PostForm("csrf_token")
	}

	if headerToken == "" {
		return false
	}

	// Compare tokens - use constant time comparison to prevent timing attacks
	return subtle.ConstantTimeCompare([]byte(cookieToken), []byte(headerToken)) == 1
}

// CSRFMiddleware is a middleware that validates CSRF tokens
func CSRFMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Only validate for state-changing methods
		if c.Request.Method == "GET" || c.Request.Method == "HEAD" || c.Request.Method == "OPTIONS" || c.Request.Method == "TRACE" {
			c.Next()
			return
		}

		// Validate CSRF token
		if !ValidateCSRFToken(c) {
			c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
				"code":    "INVALID_CSRF_TOKEN",
				"message": "Invalid or missing CSRF token",
			})
			return
		}

		c.Next()
	}
}

// HashPassword hashes a password using Argon2id
func HashPassword(password string) (string, error) {
	params := DefaultArgonParams()

	// Generate a random salt
	salt, err := GenerateRandomBytes(int(params.SaltLength))
	if err != nil {
		return "", err
	}

	// Hash the password
	hash := argon2.IDKey(
		[]byte(password),
		salt,
		params.Iterations,
		params.Memory,
		params.Parallelism,
		params.KeyLength,
	)

	// Encode the parameters, salt, and hash into a string
	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)

	// Format: $argon2id$v=19$m=memory,t=time,p=parallel$salt$hash
	encodedHash := fmt.Sprintf(
		"$argon2id$v=19$m=%d,t=%d,p=%d$%s$%s",
		params.Memory,
		params.Iterations,
		params.Parallelism,
		b64Salt,
		b64Hash,
	)

	return encodedHash, nil
}

// VerifyPassword verifies a password against a hash
func VerifyPassword(password, encodedHash string) (bool, error) {
	// Extract the parameters, salt, and hash from the encoded hash
	params, salt, hash, err := decodeHash(encodedHash)
	if err != nil {
		return false, err
	}

	// Hash the password with the same parameters and salt
	otherHash := argon2.IDKey(
		[]byte(password),
		salt,
		params.Iterations,
		params.Memory,
		params.Parallelism,
		params.KeyLength,
	)

	// Compare the hashes in constant time
	return subtle.ConstantTimeCompare(hash, otherHash) == 1, nil
}

// decodeHash decodes an Argon2id hash string into its parameters, salt, and hash
func decodeHash(encodedHash string) (*ArgonParams, []byte, []byte, error) {
	// Expected format: $argon2id$v=19$m=memory,t=time,p=parallel$salt$hash
	parts := strings.Split(encodedHash, "$")
	if len(parts) != 6 {
		return nil, nil, nil, errors.New("invalid hash format")
	}

	if parts[1] != "argon2id" {
		return nil, nil, nil, errors.New("unsupported algorithm")
	}

	// Parse the parameters
	var params ArgonParams

	paramParts := strings.Split(parts[3], ",")
	for _, part := range paramParts {
		param := strings.Split(part, "=")
		if len(param) != 2 {
			return nil, nil, nil, errors.New("invalid parameter format")
		}

		switch param[0] {
		case "m":
			val := 0
			fmt.Sscanf(param[1], "%d", &val)
			params.Memory = uint32(val)
		case "t":
			val := 0
			fmt.Sscanf(param[1], "%d", &val)
			params.Iterations = uint32(val)
		case "p":
			val := 0
			fmt.Sscanf(param[1], "%d", &val)
			params.Parallelism = uint8(val)
		}
	}

	// Decode the salt and hash
	salt, err := base64.RawStdEncoding.DecodeString(parts[4])
	if err != nil {
		return nil, nil, nil, err
	}
	params.SaltLength = uint32(len(salt))

	hash, err := base64.RawStdEncoding.DecodeString(parts[5])
	if err != nil {
		return nil, nil, nil, err
	}
	params.KeyLength = uint32(len(hash))

	return &params, salt, hash, nil
}

// SanitizeFilename sanitizes a filename to prevent path traversal attacks
func SanitizeFilename(filename string) string {
	// Remove path components
	filename = strings.ReplaceAll(filename, "/", "")
	filename = strings.ReplaceAll(filename, "\\", "")

	// Remove potentially dangerous characters
	safeFilenameRegex := regexp.MustCompile(`[^\w\d\.-]`)
	filename = safeFilenameRegex.ReplaceAllString(filename, "_")

	return filename
}

// SecureHeaders is a middleware to set security headers
func SecureHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Security headers
		c.Header("X-Content-Type-Options", "nosniff")
		c.Header("X-Frame-Options", "DENY")
		c.Header("X-XSS-Protection", "1; mode=block")
		c.Header("Content-Security-Policy", "default-src 'self'; script-src 'self'; object-src 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; font-src 'self'; frame-src 'none'; frame-ancestors 'none'")
		c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
		c.Header("Permissions-Policy", "camera=(), microphone=(), geolocation=()")

		c.Next()
	}
}

// RateLimiter is a simple rate limiter based on IP address
type RateLimiter struct {
	requests     map[string][]time.Time
	windowSize   time.Duration
	maxRequests  int
	cleanupTimer *time.Timer
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(windowSize time.Duration, maxRequests int) *RateLimiter {
	rl := &RateLimiter{
		requests:    make(map[string][]time.Time),
		windowSize:  windowSize,
		maxRequests: maxRequests,
	}

	// Start periodic cleanup
	rl.cleanupTimer = time.AfterFunc(windowSize, func() {
		rl.cleanup()
	})

	return rl
}

// Allow checks if a request from the given IP is allowed
func (rl *RateLimiter) Allow(ip string) bool {
	now := time.Now()
	cutoff := now.Add(-rl.windowSize)

	// Filter out requests older than the window
	var recent []time.Time
	for _, t := range rl.requests[ip] {
		if t.After(cutoff) {
			recent = append(recent, t)
		}
	}

	// Update requests
	if len(recent) >= rl.maxRequests {
		rl.requests[ip] = recent
		return false
	}

	rl.requests[ip] = append(recent, now)
	return true
}

// RemainingRequests returns the number of remaining requests for the given IP
func (rl *RateLimiter) RemainingRequests(ip string) int {
	now := time.Now()
	cutoff := now.Add(-rl.windowSize)

	// Filter out requests older than the window
	var count int
	for _, t := range rl.requests[ip] {
		if t.After(cutoff) {
			count++
		}
	}

	return rl.maxRequests - count
}

// cleanup removes old entries from the rate limiter
func (rl *RateLimiter) cleanup() {
	now := time.Now()
	cutoff := now.Add(-rl.windowSize)

	for ip, times := range rl.requests {
		var recent []time.Time
		for _, t := range times {
			if t.After(cutoff) {
				recent = append(recent, t)
			}
		}

		if len(recent) == 0 {
			delete(rl.requests, ip)
		} else {
			rl.requests[ip] = recent
		}
	}

	// Schedule next cleanup
	rl.cleanupTimer.Reset(rl.windowSize)
}

// Close stops the rate limiter's cleanup timer
func (rl *RateLimiter) Close() {
	rl.cleanupTimer.Stop()
}

// RateLimitMiddleware creates a middleware for rate limiting based on IP
func RateLimitMiddleware(windowSize time.Duration, maxRequests int) gin.HandlerFunc {
	limiter := NewRateLimiter(windowSize, maxRequests)

	return func(c *gin.Context) {
		ip := c.ClientIP()

		if !limiter.Allow(ip) {
			c.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{
				"code":    "RATE_LIMIT_EXCEEDED",
				"message": "Rate limit exceeded",
				"details": map[string]interface{}{
					"retryAfter": int(windowSize.Seconds()),
				},
			})
			return
		}

		// Set rate limit headers
		remaining := limiter.RemainingRequests(ip)
		c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", maxRequests))
		c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", remaining))
		c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", time.Now().Add(windowSize).Unix()))

		c.Next()
	}
}



================================================
File: internal/common/validator/input_sanitizer.go
================================================
package validator

import (
	"html"
	"regexp"
	"strings"
	"unicode"
)

// SanitizationOptions defines what sanitization rules to apply
type SanitizationOptions struct {
	TrimSpace       bool
	RemoveHTML      bool
	AllowedHTMLTags []string // Only used if RemoveHTML is false
	MaxLength       int      // 0 means no max
	DisallowControl bool
	DisallowScripts bool
}

// DefaultSanitizationOptions returns common sanitization defaults
func DefaultSanitizationOptions() SanitizationOptions {
	return SanitizationOptions{
		TrimSpace:       true,
		RemoveHTML:      true,
		AllowedHTMLTags: []string{},
		MaxLength:       0,
		DisallowControl: true,
		DisallowScripts: true,
	}
}

// RichTextSanitizationOptions returns sanitization options suitable for rich text input
func RichTextSanitizationOptions() SanitizationOptions {
	return SanitizationOptions{
		TrimSpace:       true,
		RemoveHTML:      false,
		AllowedHTMLTags: []string{"p", "br", "b", "i", "strong", "em", "ul", "ol", "li", "a", "h1", "h2", "h3", "h4", "h5", "h6"},
		MaxLength:       0,
		DisallowControl: true,
		DisallowScripts: true,
	}
}

// SanitizeString removes potentially harmful content from a string based on options
func SanitizeString(input string, options SanitizationOptions) string {
	if input == "" {
		return input
	}

	result := input

	// Trim whitespace if required
	if options.TrimSpace {
		result = strings.TrimSpace(result)
	}

	// Apply length limit if specified
	if options.MaxLength > 0 && len(result) > options.MaxLength {
		result = result[:options.MaxLength]
	}

	// Handle HTML content
	if options.RemoveHTML {
		// Completely remove all HTML tags
		result = StripHTMLTags(result)
	} else if len(options.AllowedHTMLTags) > 0 {
		// Remove only disallowed HTML tags
		result = SanitizeHTMLAllowTags(result, options.AllowedHTMLTags)
	}

	// Remove control characters if specified
	if options.DisallowControl {
		result = RemoveControlCharacters(result)
	}

	// Special handling for script-like content
	if options.DisallowScripts {
		result = RemoveScriptContent(result)
	}

	return result
}

// StripHTML removes all HTML tags from the input string
func StripHTMLTags(input string) string {
	// First handle HTML entity decoding
	input = html.UnescapeString(input)

	// Basic HTML tag removal pattern
	re := regexp.MustCompile(`<[^>]*>`)
	return re.ReplaceAllString(input, "")
}

// SanitizeHTMLAllowTags removes all HTML tags except those in the whitelist
func SanitizeHTMLAllowTags(input string, allowedTags []string) string {
	// Construct regex for allowed tags
	if len(allowedTags) == 0 {
		return StripHTMLTags(input)
	}

	// Decode HTML entities
	input = html.UnescapeString(input)

	// Replace all disallowed tags
	result := input
	allowedTagsMap := make(map[string]bool)
	for _, tag := range allowedTags {
		allowedTagsMap[strings.ToLower(tag)] = true
	}

	// This is a simplistic approach - a proper HTML sanitizer library would be better
	tagRegex := regexp.MustCompile(`<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>`)
	result = tagRegex.ReplaceAllStringFunc(result, func(match string) string {
		tag := tagRegex.FindStringSubmatch(match)[1]
		if allowedTagsMap[strings.ToLower(tag)] {
			// Keep allowed tags, but sanitize their attributes
			if strings.HasPrefix(match, "</") {
				// Closing tag - keep as is
				return match
			}
			// Opening tag with potential attributes - keep only safe ones
			return sanitizeTagAttributes(match)
		}
		// Remove disallowed tags
		return ""
	})

	return result
}

// sanitizeTagAttributes removes potentially harmful attributes from HTML tags
func sanitizeTagAttributes(tag string) string {
	// This is a simplified version - a real implementation would be more comprehensive

	// Extract tag name
	tagNameRegex := regexp.MustCompile(`<([a-zA-Z][a-zA-Z0-9]*)`)
	matches := tagNameRegex.FindStringSubmatch(tag)
	if len(matches) < 2 {
		return "" // Invalid tag format
	}
	tagName := matches[1]

	// List of allowed attributes (simplified)
	allowedAttrs := map[string]bool{
		"href": true, "title": true, "alt": true,
		"class": true, "id": true, "name": true,
	}

	// Disallow on* attributes (event handlers) and javascript: URLs
	dangerousPatterns := []*regexp.Regexp{
		regexp.MustCompile(`(?i)on\w+\s*=`),              // onclick, onload, etc.
		regexp.MustCompile(`(?i)javascript\s*:`),         // javascript: protocol
		regexp.MustCompile(`(?i)data\s*:`),               // data: URLs
		regexp.MustCompile(`(?i)expression\s*\(`),        // CSS expressions
		regexp.MustCompile(`(?i)(document|window)\s*\.`), // Direct JS object access
	}

	// Check for dangerous patterns
	for _, pattern := range dangerousPatterns {
		if pattern.MatchString(tag) {
			// Return just the tag without attributes
			return "<" + tagName + ">"
		}
	}

	// Extract attributes
	attrRegex := regexp.MustCompile(`([a-zA-Z][a-zA-Z0-9]*)\s*=\s*(['"])(.*?)\2`)
	safeTag := "<" + tagName

	attrs := attrRegex.FindAllStringSubmatch(tag, -1)
	for _, attr := range attrs {
		if len(attr) < 4 {
			continue
		}

		attrName := strings.ToLower(attr[1])
		attrValue := attr[3]

		// Only allow specific attributes
		if allowedAttrs[attrName] {
			// Further sanitize href to prevent javascript
			if attrName == "href" {
				if !strings.HasPrefix(strings.TrimSpace(strings.ToLower(attrValue)), "http") &&
					!strings.HasPrefix(strings.TrimSpace(strings.ToLower(attrValue)), "/") &&
					!strings.HasPrefix(strings.TrimSpace(strings.ToLower(attrValue)), "#") {
					continue
				}
			}

			safeTag += " " + attrName + "=\"" + html.EscapeString(attrValue) + "\""
		}
	}

	return safeTag + ">"
}

// RemoveControlCharacters removes Unicode control characters
func RemoveControlCharacters(input string) string {
	return strings.Map(func(r rune) rune {
		if unicode.IsControl(r) && r != '\n' && r != '\t' && r != '\r' {
			return -1 // Drop the character
		}
		return r
	}, input)
}

// RemoveScriptContent removes script-like content that might be used for XSS
func RemoveScriptContent(input string) string {
	// Remove <script> tags and their contents
	scriptTagRegex := regexp.MustCompile(`(?is)<script.*?>.*?</script>`)
	result := scriptTagRegex.ReplaceAllString(input, "")

	// Remove javascript: protocol from attributes
	jsProtocolRegex := regexp.MustCompile(`(?i)(href|src|action)\s*=\s*(['"])\s*javascript:.*?\2`)
	result = jsProtocolRegex.ReplaceAllStringFunc(result, func(match string) string {
		// Extract the attribute name
		parts := strings.SplitN(match, "=", 2)
		if len(parts) < 2 {
			return ""
		}
		// Return just the attribute name with empty value
		return parts[0] + "=\"\""
	})

	// Remove event handlers (on*)
	eventHandlerRegex := regexp.MustCompile(`(?i)\s+on\w+\s*=\s*(['"]).*?\1`)
	result = eventHandlerRegex.ReplaceAllString(result, "")

	// Remove other potentially dangerous tags
	dangerousTags := []string{"iframe", "object", "embed", "base", "form", "input", "button", "textarea", "select", "option"}
	for _, tag := range dangerousTags {
		tagRegex := regexp.MustCompile(`(?is)<` + tag + `[^>]*>.*?</` + tag + `>`)
		result = tagRegex.ReplaceAllString(result, "")

		// Also remove self-closing variants
		selfClosingRegex := regexp.MustCompile(`(?is)<` + tag + `[^>]*/>`)
		result = selfClosingRegex.ReplaceAllString(result, "")
	}

	// Remove data: URIs which could contain executable content
	dataURIRegex := regexp.MustCompile(`(?i)(src|href)\s*=\s*(['"])\s*data:.*?\2`)
	result = dataURIRegex.ReplaceAllStringFunc(result, func(match string) string {
		parts := strings.SplitN(match, "=", 2)
		if len(parts) < 2 {
			return ""
		}
		return parts[0] + "=\"\""
	})

	// Remove CSS expressions
	cssExprRegex := regexp.MustCompile(`(?i)expression\s*\(.*?\)`)
	result = cssExprRegex.ReplaceAllString(result, "")

	return result
}

// SanitizeEmail validates and sanitizes email addresses
func SanitizeEmail(email string) string {
	// Trim whitespace
	email = strings.TrimSpace(email)

	// Basic regex for email format
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(email) {
		return "" // Invalid email
	}

	// Convert to lowercase
	email = strings.ToLower(email)

	return email
}

// SanitizeUsername removes potentially dangerous characters from usernames
func SanitizeUsername(username string) string {
	// Trim whitespace
	username = strings.TrimSpace(username)

	// Remove special characters except _ and -
	usernameRegex := regexp.MustCompile(`[^a-zA-Z0-9_\-]`)
	username = usernameRegex.ReplaceAllString(username, "")

	// Ensure it's not empty after sanitization
	if username == "" {
		return ""
	}

	return username
}

// IsValidURL checks if a string is a valid URL
func IsValidURL(url string) bool {
	// Very basic URL validation
	url = strings.TrimSpace(url)

	// Must start with http:// or https://
	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
		return false
	}

	// Basic URL pattern
	urlRegex := regexp.MustCompile(`^(http|https)://[a-zA-Z0-9\-]+(\.[a-zA-Z0-9\-]+)+(:[0-9]+)?(/[a-zA-Z0-9\-._~:/?#[\]@!$&'()*+,;=]*)?$`)
	return urlRegex.MatchString(url)
}

// SanitizeJSON removes potentially dangerous content from JSON input
func SanitizeJSON(jsonInput string) string {
	// This is a simplified approach - consider using a proper JSON parser
	// to validate and sanitize structured data

	// Remove control characters
	jsonInput = RemoveControlCharacters(jsonInput)

	// Remove script-like content
	jsonInput = RemoveScriptContent(jsonInput)

	return jsonInput
}



================================================
File: internal/common/validator/password_validator.go
================================================
package validator

import (
	"errors"
	"regexp"
	"strings"
	"unicode"
)

var (
	// Common password errors
	ErrPasswordTooShort        = errors.New("password too short")
	ErrPasswordTooLong         = errors.New("password too long")
	ErrPasswordNoUpper         = errors.New("password must contain at least one uppercase letter")
	ErrPasswordNoLower         = errors.New("password must contain at least one lowercase letter")
	ErrPasswordNoNumber        = errors.New("password must contain at least one number")
	ErrPasswordNoSpecial       = errors.New("password must contain at least one special character")
	ErrPasswordCommonPattern   = errors.New("password contains common patterns")
	ErrPasswordFoundInBreaches = errors.New("password found in known data breaches")
)

// PasswordValidationOptions defines customizable password validation rules
type PasswordValidationOptions struct {
	MinLength      int
	MaxLength      int
	RequireUpper   bool
	RequireLower   bool
	RequireNumber  bool
	RequireSpecial bool
	CheckCommon    bool
	CheckBreaches  bool
}

// DefaultPasswordOptions returns the standard password validation options
func DefaultPasswordOptions() PasswordValidationOptions {
	return PasswordValidationOptions{
		MinLength:      8,
		MaxLength:      128,
		RequireUpper:   true,
		RequireLower:   true,
		RequireNumber:  true,
		RequireSpecial: true,
		CheckCommon:    true,
		CheckBreaches:  true,
	}
}

// ValidatePassword checks if the given password meets the security requirements
func ValidatePassword(password string, options PasswordValidationOptions) error {
	// Check length
	if len(password) < options.MinLength {
		return ErrPasswordTooShort
	}
	if options.MaxLength > 0 && len(password) > options.MaxLength {
		return ErrPasswordTooLong
	}

	// Check character requirements
	var hasUpper, hasLower, hasNumber, hasSpecial bool
	for _, char := range password {
		switch {
		case unicode.IsUpper(char):
			hasUpper = true
		case unicode.IsLower(char):
			hasLower = true
		case unicode.IsNumber(char):
			hasNumber = true
		case unicode.IsPunct(char) || unicode.IsSymbol(char):
			hasSpecial = true
		}
	}

	if options.RequireUpper && !hasUpper {
		return ErrPasswordNoUpper
	}
	if options.RequireLower && !hasLower {
		return ErrPasswordNoLower
	}
	if options.RequireNumber && !hasNumber {
		return ErrPasswordNoNumber
	}
	if options.RequireSpecial && !hasSpecial {
		return ErrPasswordNoSpecial
	}

	// Check for common patterns
	if options.CheckCommon && hasCommonPattern(password) {
		return ErrPasswordCommonPattern
	}

	// Check against breach database (simplified - would require external API in production)
	if options.CheckBreaches && isBreachedPassword(password) {
		return ErrPasswordFoundInBreaches
	}

	return nil
}

// hasCommonPattern checks for common patterns like sequences, repetitions, etc.
func hasCommonPattern(password string) bool {
	patterns := []string{
		"123", "1234", "12345", "123456", "654321",
		"qwerty", "asdfgh", "zxcvbn", "password",
		"admin", "user", "login", "welcome",
	}

	lowerPass := strings.ToLower(password)
	for _, pattern := range patterns {
		if strings.Contains(lowerPass, pattern) {
			return true
		}
	}

	// Check for repeating characters (e.g., "aaa", "111")
	repeatingPattern := regexp.MustCompile(`(.)\1{2,}`)
	if repeatingPattern.MatchString(password) {
		return true
	}

	return false
}

// isBreachedPassword checks if a password appears in known breaches
// In a real system, this would connect to a service like HIBP
func isBreachedPassword(password string) bool {
	// This is a placeholder for real breach checking logic
	// In production, you'd use a service like Have I Been Pwned via API
	// or maintain your own breach database

	// For testing/demo - list of top breached passwords
	topBreached := map[string]bool{
		"123456": true, "password": true, "123456789": true,
		"12345678": true, "12345": true, "qwerty": true,
		"abc123": true, "football": true, "1234567": true,
		"monkey": true, "111111": true, "letmein": true,
	}

	return topBreached[strings.ToLower(password)]
}

// PasswordStrengthScore calculates a score from 0-100 representing password strength
func PasswordStrengthScore(password string) int {
	// Base score starts at 0
	score := 0

	// Length contribution (up to 25 points)
	if len(password) >= 8 {
		score += 10
		// Additional points for longer passwords
		extraLength := min(len(password)-8, 16) // Capped at +16 points
		score += extraLength
	}

	// Character variety (up to 40 points)
	hasUpper := false
	hasLower := false
	hasDigit := false
	hasSpecial := false

	for _, char := range password {
		switch {
		case unicode.IsUpper(char):
			hasUpper = true
		case unicode.IsLower(char):
			hasLower = true
		case unicode.IsDigit(char):
			hasDigit = true
		case unicode.IsPunct(char) || unicode.IsSymbol(char):
			hasSpecial = true
		}
	}

	if hasUpper {
		score += 10
	}
	if hasLower {
		score += 10
	}
	if hasDigit {
		score += 10
	}
	if hasSpecial {
		score += 10
	}

	// Pattern deductions (up to -30 points)
	if hasCommonPattern(password) {
		score -= 30
	}

	// Breach database deduction
	if isBreachedPassword(password) {
		score -= 40
	}

	// Ensure score is between 0-100
	return max(0, min(100, score))
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}



================================================
File: internal/compliance/integration_auditor.go
================================================



================================================
File: internal/compliance/data_sharing/consent_manager.go
================================================



================================================
File: internal/compliance/gdpr/data_processor.go
================================================



================================================
File: internal/config/app_config.go
================================================
package config

import (
	"fmt"
	"os"
	"strconv"
	"strings"
	"time"
)

// Config represents the complete application configuration
type Config struct {
	Environment Environment
	Server      ServerConfig
	Database    DatabaseConfig
	CORS        CORSConfig
	Credentials Credentials
	Integration IntegrationConfig
	Features    FeatureFlags
}

// ServerConfig contains all HTTP server related settings
type ServerConfig struct {
	Port                   string
	ReadTimeoutSeconds     int
	WriteTimeoutSeconds    int
	IdleTimeoutSeconds     int
	ShutdownTimeoutSeconds int
}

// DatabaseConfig contains all database connection settings
type DatabaseConfig struct {
	Host            string
	Port            string
	DatabaseName    string
	UserName        string
	Password        string
	SSLMode         string
	MaxOpenConns    int
	MaxIdleConns    int
	ConnMaxLifetime time.Duration
}

// CORSConfig contains Cross-Origin Resource Sharing settings
type CORSConfig struct {
	AllowOrigins     []string
	AllowMethods     []string
	AllowHeaders     []string
	ExposeHeaders    []string
	AllowCredentials bool
	MaxAge           time.Duration
}

// Load initializes and returns the application configuration
func Load() (*Config, error) {
	// Load environment-specific configuration
	env, err := loadEnvironment()
	if err != nil {
		return nil, fmt.Errorf("failed to load environment configuration: %w", err)
	}

	// Load credentials
	creds, err := loadCredentials()
	if err != nil {
		return nil, fmt.Errorf("failed to load credentials: %w", err)
	}

	// Load integration configuration
	integration, err := loadIntegrationConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to load integration configuration: %w", err)
	}

	// Load feature flags
	features, err := loadFeatureFlags()
	if err != nil {
		return nil, fmt.Errorf("failed to load feature flags: %w", err)
	}

	// Configure server
	serverConfig := ServerConfig{
		Port:                   getEnv("SERVER_PORT", "8080"),
		ReadTimeoutSeconds:     getEnvAsInt("SERVER_READ_TIMEOUT", 30),
		WriteTimeoutSeconds:    getEnvAsInt("SERVER_WRITE_TIMEOUT", 30),
		IdleTimeoutSeconds:     getEnvAsInt("SERVER_IDLE_TIMEOUT", 60),
		ShutdownTimeoutSeconds: getEnvAsInt("SERVER_SHUTDOWN_TIMEOUT", 30),
	}

	// Configure database
	dbConfig := DatabaseConfig{
		Host:            getEnv("DB_HOST", "localhost"),
		Port:            getEnv("DB_PORT", "5432"),
		DatabaseName:    getEnv("DB_NAME", "tnp_rgpv"),
		UserName:        getEnv("DB_USER", "postgres"),
		Password:        creds.DatabasePassword,
		SSLMode:         getEnv("DB_SSL_MODE", "require"),
		MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 25),
		MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 10),
		ConnMaxLifetime: time.Duration(getEnvAsInt("DB_CONN_MAX_LIFETIME", 300)) * time.Second,
	}

	// Configure CORS
	corsConfig := CORSConfig{
		AllowOrigins:     strings.Split(getEnv("CORS_ALLOW_ORIGINS", "*"), ","),
		AllowMethods:     strings.Split(getEnv("CORS_ALLOW_METHODS", "GET,POST,PUT,PATCH,DELETE,OPTIONS"), ","),
		AllowHeaders:     strings.Split(getEnv("CORS_ALLOW_HEADERS", "Origin,Content-Type,Accept,Authorization"), ","),
		ExposeHeaders:    strings.Split(getEnv("CORS_EXPOSE_HEADERS", "Content-Length,Content-Type"), ","),
		AllowCredentials: getEnvAsBool("CORS_ALLOW_CREDENTIALS", false),
		MaxAge:           time.Duration(getEnvAsInt("CORS_MAX_AGE", 300)) * time.Second,
	}

	return &Config{
		Environment: *env,
		Server:      serverConfig,
		Database:    dbConfig,
		CORS:        corsConfig,
		Credentials: *creds,
		Integration: *integration,
		Features:    *features,
	}, nil
}

// Helper function to get environment variables with fallbacks
func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

// Helper function to get environment variables as integers
func getEnvAsInt(key string, fallback int) int {
	if value, exists := os.LookupEnv(key); exists {
		if intValue, err := strconv.Atoi(value); err == nil {
			return intValue
		}
	}
	return fallback
}

// Helper function to get environment variables as booleans
func getEnvAsBool(key string, fallback bool) bool {
	if value, exists := os.LookupEnv(key); exists {
		if boolValue, err := strconv.ParseBool(value); err == nil {
			return boolValue
		}
	}
	return fallback
}

// Helper function to get environment variables as string slices
func getEnvAsSlice(key string, fallback []string, separator string) []string {
	if value, exists := os.LookupEnv(key); exists && value != "" {
		return strings.Split(value, separator)
	}
	return fallback
}


================================================
File: internal/config/credentials.go
================================================
package config

import (
	"bufio"
	"errors"
	"os"
	"strings"
)

// Credentials contains all sensitive information used by the application
type Credentials struct {
	DatabasePassword string
	APIKeys          map[string]string
	JWTSecret        string
}

// loadCredentials initializes credentials from environment variables or .env file
func loadCredentials() (*Credentials, error) {
	// Load .env file if it exists
	loadEnvFile()

	// Get credentials from environment variables
	return loadCredentialsFromEnv()
}

// loadEnvFile loads environment variables from .env file if present
func loadEnvFile() {
	// Determine which .env file to use based on environment
	env, err := loadEnvironment()
	if err != nil {
		return // If can't determine environment, continue with default .env
	}

	// Choose appropriate .env file
	envFileName := ".env"
	if env.Production {
		envFileName = ".env.production"
	} else if env.Testing {
		envFileName = ".env.testing"
	} else {
		envFileName = ".env.development"
	}

	// Fall back to .env if the specific file doesn't exist
	if _, err := os.Stat(envFileName); os.IsNotExist(err) {
		envFileName = ".env"
	}

	// Open the .env file
	file, err := os.Open(envFileName)
	if err != nil {
		// It's okay if the file doesn't exist, we'll just use existing env vars
		return
	}
	defer file.Close()

	// Parse the file line by line
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip empty lines and comments
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Split by first = sign
		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue // Invalid format, skip this line
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		// Remove quotes if present
		value = strings.Trim(value, `"'`)

		// Only set if environment variable is not already set
		if _, exists := os.LookupEnv(key); !exists {
			os.Setenv(key, value)
		}
	}
}

// loadCredentialsFromEnv loads credentials from environment variables
func loadCredentialsFromEnv() (*Credentials, error) {
	dbPassword := os.Getenv("DB_PASSWORD")
	if dbPassword == "" {
		return nil, errors.New("database password (DB_PASSWORD) not set")
	}

	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {
		return nil, errors.New("JWT secret (JWT_SECRET) not set")
	}

	// Initialize API keys map
	apiKeys := make(map[string]string)
	
	// Add any defined API keys
	// Look for any environment variables with API_KEY_ prefix
	for _, envVar := range os.Environ() {
		parts := strings.SplitN(envVar, "=", 2)
		if len(parts) != 2 {
			continue
		}
		
		key := parts[0]
		value := parts[1]
		
		if strings.HasPrefix(key, "API_KEY_") {
			// Convert API_KEY_EXTERNAL_SERVICE to external_service
			serviceName := strings.ToLower(strings.TrimPrefix(key, "API_KEY_"))
			apiKeys[serviceName] = value
		}
	}

	return &Credentials{
		DatabasePassword: dbPassword,
		APIKeys:          apiKeys,
		JWTSecret:        jwtSecret,
	}, nil
}


================================================
File: internal/config/environment.go
================================================
package config

import (
	"fmt"
	"os"
)

// Environment contains environment-specific configuration settings
type Environment struct {
	Name       string
	Production bool
	Testing    bool
	Debug      bool
	LogLevel   string
}

// Valid environment names
const (
	EnvDevelopment = "development"
	EnvStaging     = "staging"
	EnvProduction  = "production"
	EnvTesting     = "testing"
)

// loadEnvironment initializes and returns environment configuration
func loadEnvironment() (*Environment, error) {
	// Get environment name from ENV variable
	envName := os.Getenv("APP_ENV")
	if envName == "" {
		envName = EnvDevelopment // Default to development
	}

	// Validate environment name
	if !isValidEnv(envName) {
		return nil, fmt.Errorf("invalid environment name: %s", envName)
	}

	// Create environment configuration
	env := &Environment{
		Name:       envName,
		Production: envName == EnvProduction,
		Testing:    envName == EnvTesting,
		Debug:      getEnvAsBool("DEBUG", envName != EnvProduction),
		LogLevel:   getLogLevel(envName),
	}

	return env, nil
}

// isValidEnv checks if the environment name is valid
func isValidEnv(env string) bool {
	validEnvs := []string{EnvDevelopment, EnvStaging, EnvProduction, EnvTesting}
	for _, validEnv := range validEnvs {
		if env == validEnv {
			return true
		}
	}
	return false
}

// getLogLevel returns the appropriate log level based on the environment
func getLogLevel(env string) string {
	// Override with explicit setting if available
	if level := os.Getenv("LOG_LEVEL"); level != "" {
		return level
	}

	// Default levels based on environment
	switch env {
	case EnvProduction:
		return "info"
	case EnvStaging:
		return "debug"
	case EnvTesting:
		return "debug"
	default:
		return "debug"
	}
}


================================================
File: internal/config/feature_flags.go
================================================
package config

import (
	"os"
	"strings"
)

// FeatureFlags represents all feature toggles used in the application
type FeatureFlags struct {
	EnableAdvancedSearch     bool
	EnableNotifications      bool
	EnableCaching            bool
	EnableRateLimiting       bool
	EnableUserTracking       bool
	EnableDocumentGeneration bool
	ExperimentalFeatures     map[string]bool
}

// loadFeatureFlags initializes feature flags based on environment variables
func loadFeatureFlags() (*FeatureFlags, error) {
	flags := &FeatureFlags{
		EnableAdvancedSearch:     getEnvAsBool("FEATURE_ADVANCED_SEARCH", false),
		EnableNotifications:      getEnvAsBool("FEATURE_NOTIFICATIONS", true),
		EnableCaching:            getEnvAsBool("FEATURE_CACHING", true),
		EnableRateLimiting:       getEnvAsBool("FEATURE_RATE_LIMITING", true),
		EnableUserTracking:       getEnvAsBool("FEATURE_USER_TRACKING", false),
		EnableDocumentGeneration: getEnvAsBool("FEATURE_DOCUMENT_GENERATION", true),
		ExperimentalFeatures:     loadExperimentalFeatures(),
	}

	return flags, nil
}

// loadExperimentalFeatures loads any experimental features from a comma-separated list
func loadExperimentalFeatures() map[string]bool {
	features := make(map[string]bool)
	
	// Get experimental features from environment variable
	expFeaturesStr := os.Getenv("EXPERIMENTAL_FEATURES")
	if expFeaturesStr == "" {
		return features
	}
	
	// Parse comma-separated list
	expFeaturesList := strings.Split(expFeaturesStr, ",")
	for _, feature := range expFeaturesList {
		feature = strings.TrimSpace(feature)
		if feature != "" {
			features[feature] = true
		}
	}
	
	return features
}

// IsExperimentalFeatureEnabled checks if a specific experimental feature is enabled
func (f *FeatureFlags) IsExperimentalFeatureEnabled(featureName string) bool {
	if enabled, exists := f.ExperimentalFeatures[featureName]; exists {
		return enabled
	}
	return false
}


================================================
File: internal/config/integration_config.go
================================================
package config

import (
	"fmt"
	"time"
)

// IntegrationConfig contains configuration for external service integrations
type IntegrationConfig struct {
	Email       EmailConfig
	SMS         SMSConfig
	Storage     StorageConfig
	Monitoring  MonitoringConfig
	ExternalAPI ExternalAPIConfig
}

// EmailConfig contains email service configuration
type EmailConfig struct {
	Provider          string
	SenderEmail       string
	SenderName        string
	APIKey            string
	TemplateDirectory string
	MaxRetries        int
	RetryInterval     time.Duration
	Enabled           bool
}

// SMSConfig contains SMS service configuration
type SMSConfig struct {
	Provider      string
	AccountSID    string
	AuthToken     string
	PhoneNumber   string
	MaxRetries    int
	RetryInterval time.Duration
	Enabled       bool
}

// StorageConfig contains file storage configuration
type StorageConfig struct {
	Provider   string // "s3", "local", etc.
	BucketName string
	Region     string
	BasePath   string
	Enabled    bool
}

// MonitoringConfig contains monitoring and logging configuration
type MonitoringConfig struct {
	Provider       string // "cloudwatch", "datadog", etc.
	APIKey         string
	FlushInterval  time.Duration
	SamplingRate   float64
	EnabledMetrics []string
	Enabled        bool
}

// ExternalAPIConfig contains configuration for external API integrations
type ExternalAPIConfig struct {
	BaseURL      string
	APIKey       string
	Timeout      time.Duration
	MaxRetries   int
	RetryBackoff time.Duration
	Enabled      bool
}

// loadIntegrationConfig initializes integration configurations
func loadIntegrationConfig() (*IntegrationConfig, error) {
	// Load environment to check if in production
	env, err := loadEnvironment()
	if err != nil {
		return nil, fmt.Errorf("failed to load environment for integration config: %w", err)
	}

	// Get credentials for API keys if needed
	creds, err := loadCredentials()
	if err != nil {
		return nil, fmt.Errorf("failed to load credentials for integration config: %w", err)
	}

	// Email configuration
	emailConfig := EmailConfig{
		Provider:          getEnv("EMAIL_PROVIDER", "ses"),
		SenderEmail:       getEnv("EMAIL_SENDER", "no-reply@tnprgpv.com"),
		SenderName:        getEnv("EMAIL_SENDER_NAME", "TNP RGPV"),
		APIKey:            getAPIKey(creds, "email_provider", getEnv("EMAIL_API_KEY", "")),
		TemplateDirectory: getEnv("EMAIL_TEMPLATE_DIR", "./templates/email"),
		MaxRetries:        getEnvAsInt("EMAIL_MAX_RETRIES", 3),
		RetryInterval:     time.Duration(getEnvAsInt("EMAIL_RETRY_INTERVAL", 5)) * time.Second,
		Enabled:           getEnvAsBool("EMAIL_ENABLED", true),
	}

	// SMS configuration
	smsConfig := SMSConfig{
		Provider:      getEnv("SMS_PROVIDER", "twilio"),
		AccountSID:    getEnv("SMS_ACCOUNT_SID", ""),
		AuthToken:     getAPIKey(creds, "sms_provider", getEnv("SMS_AUTH_TOKEN", "")),
		PhoneNumber:   getEnv("SMS_PHONE_NUMBER", ""),
		MaxRetries:    getEnvAsInt("SMS_MAX_RETRIES", 3),
		RetryInterval: time.Duration(getEnvAsInt("SMS_RETRY_INTERVAL", 5)) * time.Second,
		Enabled:       getEnvAsBool("SMS_ENABLED", env.Production),
	}

	// Storage configuration
	storageConfig := StorageConfig{
		Provider:   getEnv("STORAGE_PROVIDER", "s3"),
		BucketName: getEnv("STORAGE_BUCKET_NAME", "tnp-rgpv-files"),
		Region:     getEnv("AWS_REGION", "us-east-1"),
		BasePath:   getEnv("STORAGE_BASE_PATH", "uploads"),
		Enabled:    getEnvAsBool("STORAGE_ENABLED", true),
	}

	// Monitoring configuration
	monitoringConfig := MonitoringConfig{
		Provider:      getEnv("MONITORING_PROVIDER", "cloudwatch"),
		APIKey:        getAPIKey(creds, "monitoring", getEnv("MONITORING_API_KEY", "")),
		FlushInterval: time.Duration(getEnvAsInt("MONITORING_FLUSH_INTERVAL", 10)) * time.Second,
		SamplingRate:  float64(getEnvAsInt("MONITORING_SAMPLING_RATE", 100)) / 100.0,
		EnabledMetrics: getEnvAsSlice(
			"MONITORING_ENABLED_METRICS",
			[]string{"api.requests", "db.queries", "errors"},
			",",
		),
		Enabled: getEnvAsBool("MONITORING_ENABLED", env.Production),
	}

	// External API configuration
	externalAPIConfig := ExternalAPIConfig{
		BaseURL:      getEnv("EXTERNAL_API_BASE_URL", "https://api.example.com"),
		APIKey:       getAPIKey(creds, "external_service", getEnv("EXTERNAL_API_KEY", "")),
		Timeout:      time.Duration(getEnvAsInt("EXTERNAL_API_TIMEOUT", 30)) * time.Second,
		MaxRetries:   getEnvAsInt("EXTERNAL_API_MAX_RETRIES", 3),
		RetryBackoff: time.Duration(getEnvAsInt("EXTERNAL_API_RETRY_BACKOFF", 5)) * time.Second,
		Enabled:      getEnvAsBool("EXTERNAL_API_ENABLED", false),
	}

	return &IntegrationConfig{
		Email:       emailConfig,
		SMS:         smsConfig,
		Storage:     storageConfig,
		Monitoring:  monitoringConfig,
		ExternalAPI: externalAPIConfig,
	}, nil
}

// getAPIKey retrieves an API key from the credentials or falls back to a provided default
func getAPIKey(creds *Credentials, keyName string, defaultValue string) string {
	if creds != nil && creds.APIKeys != nil {
		if key, exists := creds.APIKeys[keyName]; exists && key != "" {
			return key
		}
	}
	return defaultValue
}


================================================
File: internal/domain/ai/model.go
================================================



================================================
File: internal/domain/ai/repository.go
================================================



================================================
File: internal/domain/ai/service.go
================================================



================================================
File: internal/domain/coordinator/model.go
================================================



================================================
File: internal/domain/coordinator/repository.go
================================================



================================================
File: internal/domain/coordinator/service.go
================================================



================================================
File: internal/domain/design/model.go
================================================



================================================
File: internal/domain/design/repository.go
================================================



================================================
File: internal/domain/design/service.go
================================================



================================================
File: internal/domain/event/model.go
================================================



================================================
File: internal/domain/event/repository.go
================================================



================================================
File: internal/domain/event/service.go
================================================



================================================
File: internal/domain/integration/ai_provider.go
================================================



================================================
File: internal/domain/integration/design_provider.go
================================================



================================================
File: internal/domain/integration/file_storage_provider.go
================================================



================================================
File: internal/domain/integration/notification_provider.go
================================================



================================================
File: internal/domain/platform_profile/model.go
================================================
// 1. TODO: Include gradually - line: 42
// 2. TODO: Include OAuth
// 3. TODO: Add models for soft delete recovery.

// Rest models are final.
// No changes needed.

package platform_profile

import (
	"time"

	"github.com/google/uuid"
)

// Status represents the current state of a platform profile
type Status string

const (
	StatusActivated   Status = "activated"
	StatusDeactivated Status = "deactivated"
	StatusSuspended   Status = "suspended"
	StatusPending     Status = "pending"
	StatusLocked      Status = "locked"
)

// PlatformProfile represents a user account on the platform
// This is separate from student-specific information
type PlatformProfile struct {
	ID                  uuid.UUID  `json:"id"`
	Username            string     `json:"username"`
	Email               string     `json:"email"`
	PasswordHash        string     `json:"-"`
	Status              Status     `json:"status"`
	VerifiedAt          *time.Time `json:"verified_at,omitempty"`
	LastLoginAt         *time.Time `json:"last_login_at,omitempty"`
	FailedLoginAttempts int        `json:"-"`
	CreatedAt           time.Time  `json:"created_at"`
	UpdatedByUserAt     time.Time  `json:"updated_by_user_at"`
	UpdatedBySystemAt   time.Time  `json:"updated_by_system_at"`
}

// CreateProfileRequest represents data needed to create a new profile
type CreateProfileRequest struct {
	Username string `json:"username" validate:"required,min=3,max=30"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=8"`
}

// GetProfileRequest represents data needed to get an existing profile
type GetProfileRequest struct {
	ID       *uuid.UUID `json:"id,omitempty" validate:"omitempty,uuid4"`
	Username *string    `json:"username,omitempty" validate:"omitempty,min=3,max=30"`
	Email    *string    `json:"email,omitempty" validate:"omitempty,email"`
}

// UpdateProfileRequest represents data that can be updated for a profile
type UpdateProfileRequest struct {
	// Used pointers to string (*string) to enable partial updates and to check incoming data explicitely
	// it allows for the distinction between "field not provided" and "field provided but empty"
	// needed because there's an important distinction between
	// "don't change this field" (nil) and "change this field to empty" (pointer to empty string).
	Username *string `json:"username,omitempty" validate:"omitempty,min=3,max=30"`
	Email    *string `json:"email,omitempty" validate:"omitempty,email"`
}

// LoginRequest represents the credentials needed for login
type LoginRequest struct {
	// omitempty is used to give users the liberty to login using either Username or Email.
	Username string `json:"username,omitempty"`
	Email    string `json:"email,omitempty"`
	Password string `json:"password" validate:"required"`
}

// GetProfileRequest represents data needed to get an existing profile
type GetSoftDeletedProfileRequest struct {
	Username *string `json:"username,omitempty" validate:"omitempty,min=3,max=30"`
	Email    *string `json:"email,omitempty" validate:"omitempty,email"`
}

// PasswordResetRequest represents data needed to request password reset
type PasswordResetRequest struct {
	Email string `json:"email" validate:"required,email"`
}

// PasswordChangeRequest represents data needed for password change
type PasswordChangeRequest struct {
	CurrentPassword string `json:"current_password" validate:"required"`
	NewPassword     string `json:"new_password" validate:"required,min=8,nefield=CurrentPassword"`
}

// PasswordResetToken stores information for password reset functionality
type PasswordResetToken struct {
	ProfileID uuid.UUID `json:"-"`
	Token     string    `json:"-"`
	ExpiresAt time.Time `json:"-"` // Kept redundantly for admin tasks like auditing, lifetime extension, etc. and adding security.
	IsUsed    bool      `json:"-"`
	CreatedAt time.Time `json:"-"`
}

// PasswordResetConfirmation represents data needed to confirm password reset
type PasswordResetConfirmation struct {
	Token       string `json:"token" validate:"required"`
	NewPassword string `json:"new_password" validate:"required,min=8"`
}

// ProfilePreference stores user preferences for the platform
type ProfilePreference struct {
	ID                 uuid.UUID `json:"id"`
	ProfileID          uuid.UUID `json:"profile_id"`
	NotificationsEmail bool      `json:"notifications_email"`

	// TODO: 1.
	// NotificationsPush  bool      `json:"notifications_push"`
	// NotificationsSMS   bool      `json:"notifications_sms"`

	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`

	// Store in frontend cache and preferences.
	// Language  string    `json:"language"`
	// DarkModeOn      bool      `json:"dark_mode_on"`
}

// ProfileRole associates a profile with one or more roles
type ProfileRole struct {
	ProfileID  uuid.UUID `json:"profile_id"`
	RoleID     uuid.UUID `json:"role_id"`
	AssignedAt time.Time `json:"assigned_at"`
}



================================================
File: internal/domain/platform_profile/repository.go
================================================
package platform_profile

import (
	"context"

	"github.com/google/uuid"
)

// Repository defines the data access interface for platform profiles
type Repository interface {

	// Profile operations (Verification)
	UsernameExists(ctx context.Context, username string) (bool, error)
	EmailExists(ctx context.Context, email string) (bool, error)

	// Profile operations (CRUD)
	CreateProfile(ctx context.Context, profile *PlatformProfile) error
	GetProfileByID(ctx context.Context, id uuid.UUID) (*PlatformProfile, error)
	GetProfileByEmail(ctx context.Context, email string) (*PlatformProfile, error)
	GetProfileByUsername(ctx context.Context, username string) (*PlatformProfile, error)

	UpdateProfile(ctx context.Context, profile *PlatformProfile) error

	SoftDeleteProfile(ctx context.Context, id uuid.UUID) error

	// Status management
	VerifyProfile(ctx context.Context, id uuid.UUID) error
	UpdateStatus(ctx context.Context, id uuid.UUID, status Status) error

	// Password / Authentication  operations
	CreatePasswordResetToken(ctx context.Context, resetToken *PasswordResetToken) error
	GetPasswordResetToken(ctx context.Context, token string) (*PasswordResetToken, error)
	MarkPasswordResetTokenUsed(ctx context.Context, token string) error
	DeleteOtherPasswordResetTokens(ctx context.Context, profileID uuid.UUID) error
	UpdatePassword(ctx context.Context, id uuid.UUID, passwordHash string) error

	// Recovery operations
	GetSoftDeletedProfileByUsername(ctx context.Context, username string) (*PlatformProfile, error)
	GetSoftDeletedProfileByEmail(ctx context.Context, email string) (*PlatformProfile, error)
	RestoreSoftDeletedProfile(ctx context.Context, id uuid.UUID) error

	// Hard / Permanaent delete operations
	HardDeleteProfile(ctx context.Context, id uuid.UUID) error

	// Role associations
	AssignRoleToProfile(ctx context.Context, profileID, roleID uuid.UUID) error
	GetProfileRoles(ctx context.Context, profileID uuid.UUID) ([]uuid.UUID, error)
	RemoveRoleFromProfile(ctx context.Context, profileID, roleID uuid.UUID) error

	// Preferences
	SavePreferences(ctx context.Context, prefs *ProfilePreference) error
	GetPreferences(ctx context.Context, profileID uuid.UUID) (*ProfilePreference, error)

	// Bulk/query operations (only for admin)
	GetProfiles(ctx context.Context, offset, limit int, filters map[string]interface{}) ([]*PlatformProfile, int, error)
	GetProfilesByRole(ctx context.Context, roleID uuid.UUID, page, pageSize int) ([]*PlatformProfile, int, error)
	GetProfilesByPreferences(ctx context.Context, preferences map[string]interface{}, page, pageSize int) ([]*PlatformProfile, int, error)
	DeleteProfiles(ctx context.Context, profileIDs []uuid.UUID, hardDelete bool) error

	// Login management
	RecordLogin(ctx context.Context, id uuid.UUID) error

	// Failed Login Attempt management
	IncrementFailedLoginAttempts(ctx context.Context, id uuid.UUID) error
	ResetFailedLoginAttempts(ctx context.Context, id uuid.UUID) error
}



================================================
File: internal/domain/platform_profile/service.go
================================================
// 1. TODO: Implement VerifyProfile
// 2. TODO: Implement ActivateProfile
// 3. TODO: Reset Preferences Function.
// 4. TODO: Save Preferences Function.
// 5. TODO: List All Profiles Function.
// 6. TODO: Add Lock and Unlock mechanisms for multiple failed logins.
// 7. TODO: Implement ValidatePasswordResetToken
// 8. TODO: Implement SendPasswordResetEmail
// 9. TODO: Implement ExpireOldResetTokens
// 10. TODO: Implement ForcePasswordChange
// 11. TODO: Implement DeleteExpiredResetTokens

package platform_profile

import (
	"context"
	"server/pkg/logger"
	"time"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"server/internal/common/errors"
	"server/internal/domain/role"
)

// Service defines the business logic for platform profiles
type Service interface {
	// Account Management (CRUD)
	RegisterProfile(ctx context.Context, req CreateProfileRequest) (*PlatformProfile, error)
	GetProfile(ctx context.Context, req GetProfileRequest) (*PlatformProfile, error)
	UpdateProfile(ctx context.Context, id uuid.UUID, req UpdateProfileRequest) (*PlatformProfile, error)
	SoftDeleteProfile(ctx context.Context, id uuid.UUID) error

	// Account Verification and Status Management
	VerifyProfile(ctx context.Context, id uuid.UUID) error
	ActivateProfile(ctx context.Context, id uuid.UUID) error
	SuspendProfile(ctx context.Context, id uuid.UUID) error
	DeactivateProfile(ctx context.Context, id uuid.UUID) error

	// Account Restoration
	GetSoftDeletedProfile(ctx context.Context, req GetSoftDeletedProfileRequest) (*PlatformProfile, error)

	// Authentication
	AuthenticateProfile(ctx context.Context, req LoginRequest) (*PlatformProfile, error)
	ChangePassword(ctx context.Context, id uuid.UUID, req PasswordChangeRequest) error
	RequestPasswordReset(ctx context.Context, req PasswordResetRequest) error
	ConfirmPasswordReset(ctx context.Context, req PasswordResetConfirmation) error
	LockAccountAfterFailedAttempts(ctx context.Context, id uuid.UUID, maxAttempts int) error
	UnlockAccount(ctx context.Context, id uuid.UUID) error
	ValidatePasswordResetToken(ctx context.Context, token string) (*PasswordResetToken, error)
	SendPasswordResetEmail(ctx context.Context, email string, resetLink string) error
	ExpireOldResetTokens(ctx context.Context, profileID uuid.UUID) error
	ForcePasswordChange(ctx context.Context, id uuid.UUID) error
	DeleteExpiredResetTokens(ctx context.Context) error

	// Role Management
	AssignRole(ctx context.Context, profileID uuid.UUID, roleID uuid.UUID) error
	RemoveRole(ctx context.Context, profileID uuid.UUID, roleID uuid.UUID) error
	HasRole(ctx context.Context, profileID uuid.UUID, roleName string) (bool, error)

	// Preferences
	UpdatePreferences(ctx context.Context, profileID uuid.UUID, prefs ProfilePreference) error
	GetPreferences(ctx context.Context, profileID uuid.UUID) (*ProfilePreference, error)

	// Administrative functions
	SearchProfiles(ctx context.Context, query string, page, pageSize int) ([]*PlatformProfile, int, error)
	ListProfilesByRole(ctx context.Context, roleID uuid.UUID, page, pageSize int) ([]*PlatformProfile, int, error)
	ResetPreferencesToDefault(ctx context.Context, profileID uuid.UUID) (*ProfilePreference, error)
}

// The "service" struct is the concrete implementation of the "Service" interface.
type service struct {
	repo        Repository
	roleService role.Service

	// tokenGenerator utils.TokenGenerator
	logger logger.Logger
}

// NewService creates a new platform profile service
func NewService(
	repo Repository,
	roleService role.Service,
	// tokenGen utils.TokenGenerator,
	logger logger.Logger,
) Service {
	return &service{
		repo:        repo,
		roleService: roleService,
		// tokenGenerator: tokenGen,
		logger: logger,
	}
}

// RegisterProfile creates a new platform profile
func (s *service) RegisterProfile(ctx context.Context, req CreateProfileRequest) (*PlatformProfile, error) {
	s.logger.Debug("Starting profile registration", "username", req.Username, "email", req.Email)

	// Check if username already exists
	existingUser, err := s.repo.UsernameExists(ctx, req.Username)
	if err != nil && !errors.IsNotFoundErrorDomain(err) {
		s.logger.Error("Failed to check username existence", "username", req.Username, "error", err)
		return nil, errors.NewDatabaseError("fetching username", err)
	}
	if existingUser {
		s.logger.Warn("Username already exists", "username", req.Username)
		return nil, errors.NewConflictError("username", map[string]interface{}{"username": req.Username})
	}

	// Check if email already exists
	existingEmail, err := s.repo.EmailExists(ctx, req.Email)
	if err != nil && !errors.IsNotFoundErrorDomain(err) {
		s.logger.Error("Failed to check email existence", "email", req.Email, "error", err)
		return nil, errors.NewDatabaseError("fetching email", err)
	}
	if existingEmail {
		s.logger.Warn("Email already exists", "email", req.Email)
		return nil, errors.NewConflictError("email", map[string]interface{}{"email": req.Email})
	}

	// Hash password securely
	passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		s.logger.Error("Failed to hash password", "username", req.Username, "error", err)
		return nil, errors.NewBusinessError("PASSWORD_HASHING_FAILED", "password hashing failed", nil)
	}

	now := time.Now()
	profile := &PlatformProfile{
		ID:                  uuid.New(),
		Username:            req.Username,
		Email:               req.Email,
		PasswordHash:        string(passwordHash),
		Status:              StatusPending, // Default to 'pending' for new profiles
		FailedLoginAttempts: 0,
		CreatedAt:           now,
		UpdatedByUserAt:     now,
		UpdatedBySystemAt:   now,
	}

	// Save profile to database
	if err := s.repo.CreateProfile(ctx, profile); err != nil {
		s.logger.Error("Failed to create profile", "username", req.Username, "error", err)
		return nil, errors.NewBusinessError("PROFILE_CREATION_FAILED", "failed to create profile", nil)
	}

	// Create default preferences (not a blocker if it fails)
	prefs := &ProfilePreference{
		ID:                 uuid.New(),
		ProfileID:          profile.ID,
		NotificationsEmail: true,
		CreatedAt:          now,
		UpdatedAt:          now,
	}
	if err := s.repo.SavePreferences(ctx, prefs); err != nil {
		s.logger.Warn("Failed to create default preferences", "profile_id", profile.ID, "error", err)
	}

	// Assign default role if needed
	defaultRoleID, err := s.roleService.GetDefaultRoleID(ctx)
	if err != nil {
		s.logger.Warn("Failed to get default role for profile", "profile_id", profile.ID, "error", err)
	} else {
		err = s.repo.AssignRoleToProfile(ctx, profile.ID, defaultRoleID)
		if err != nil {
			s.logger.Warn("Failed to assign default role", "profile_id", profile.ID, "role_id", defaultRoleID, "error", err)
		}
	}

	if err != nil {
		s.logger.Error("Failed to commit transaction for profile registration", "error", err)
		return nil, errors.NewDatabaseError("transaction commit", err)
	}

	s.logger.Info("Profile registered successfully", "username", req.Username, "profile_id", profile.ID)

	// Remove password hash before returning response
	profile.PasswordHash = ""
	return profile, nil
}

// GetProfile retrieves a profile based on provided identifier (ID, username, or email)
func (s *service) GetProfile(ctx context.Context, req GetProfileRequest) (*PlatformProfile, error) {

	var profile *PlatformProfile
	var err error

	// Log which identifier is being used
	if req.ID != nil {
		s.logger.Debug(
			"Retrieving profile by ID",
			"profileID",
			*req.ID,
		)

		profile, err = s.repo.GetProfileByID(ctx, *req.ID)

		if err != nil {
			s.logger.Error(
				"Failed to retrieve profile by ID",
				"profileID", *req.ID,
				"error", err,
			)
			return nil, err
		}

		s.logger.Debug(
			"Profile retrieved successfully by ID",
			"profileID", *req.ID,
		)

	} else if req.Username != nil {
		s.logger.Debug(
			"Retrieving profile by username",
			"username",
			*req.Username,
		)

		profile, err = s.repo.GetProfileByUsername(ctx, *req.Username)

		if err != nil {
			s.logger.Error(
				"Failed to retrieve profile by username",
				"username", *req.Username,
				"error", err,
			)
			return nil, err
		}

		s.logger.Debug(
			"Profile retrieved successfully by username",
			"username", *req.Username,
			"profileID", profile.ID,
		)

	} else if req.Email != nil {
		s.logger.Debug(
			"Retrieving profile by email",
			"email",
			*req.Email,
		)

		profile, err = s.repo.GetProfileByEmail(ctx, *req.Email)

		if err != nil {
			s.logger.Error(
				"Failed to retrieve profile by email",
				"email", *req.Email,
				"error", err,
			)
			return nil, err
		}

		s.logger.Debug(
			"Profile retrieved successfully by email",
			"email", *req.Email,
			"profileID", profile.ID,
		)

	} else {
		errMsg := "no valid identifier provided for profile retrieval"
		s.logger.Error(errMsg)
		return nil, errors.NewValidationError(errMsg, nil)
	}

	// Don't expose password hash
	profile.PasswordHash = ""
	return profile, nil
}

// UpdateProfile updates a profile's information
func (s *service) UpdateProfile(ctx context.Context, id uuid.UUID, req UpdateProfileRequest) (*PlatformProfile, error) {

	s.logger.Info(
		"Updating profile",
		"profileID", id,
		"usernameChange", req.Username != nil,
		"emailChange", req.Email != nil,
	)

	profile, err := s.repo.GetProfileByID(ctx, id)

	if err != nil {
		s.logger.Error(
			"Failed to retrieve profile for update",
			"profileID", id,
			"error", err,
		)
		return nil, err
	}

	if req.Username != nil {
		// Check if new username is available
		if *req.Username != profile.Username {
			s.logger.Debug(
				"Checking username availability",
				"profileID", id,
				"newUsername", *req.Username,
			)

			existing, err := s.repo.GetProfileByUsername(ctx, *req.Username)

			if err == nil && existing != nil {
				s.logger.Warn(
					"Username already taken",
					"profileID", id,
					"requestedUsername", *req.Username,
				)

				return nil, errors.NewDomainError(
					"username already taken",
					errors.ValidationError,
					"USERNAME_TAKEN", // Add a unique error code
					nil,              // No additional details
					nil,              // No underlying error
				)
			}

			profile.Username = *req.Username

			s.logger.Debug(
				"Username updated",
				"profileID", id,
				"newUsername", *req.Username,
			)
		}
	}

	if req.Email != nil {
		// Check if new email is available
		if *req.Email != profile.Email {
			s.logger.Debug(
				"Checking email availability",
				"profileID", id,
				"newEmail", *req.Email,
			)

			existing, err := s.repo.GetProfileByEmail(ctx, *req.Email)

			if err == nil && existing != nil {
				s.logger.Warn(
					"Email already registered",
					"profileID", id,
					"requestedEmail", *req.Email,
				)

				return nil, errors.NewDomainError(
					"email already registered",
					errors.ValidationError,
					"EMAIL_REGISTERED", // Add a unique error code
					nil,                // No additional details
					nil,                // No underlying error
				)

			}
			profile.Email = *req.Email
			s.logger.Debug(
				"Email updated",
				"profileID", id,
				"newEmail", *req.Email,
			)
		}
	}

	// Set timestamps at the service level
	now := time.Now()

	profile.UpdatedByUserAt = now
	profile.UpdatedBySystemAt = now

	if err := s.repo.UpdateProfile(ctx, profile); err != nil {
		s.logger.Error(
			"Failed to update profile in database",
			"profileID", id,
			"error", err,
		)
		return nil, errors.NewDatabaseError("updating profile", err)
	}

	s.logger.Info("Profile updated successfully", "profileID", id)

	// Don't expose password hash
	profile.PasswordHash = ""
	return profile, nil
}

// DeleteProfile soft-deletes a profile
func (s *service) SoftDeleteProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Debug("Attempting to soft-delete profile", "id", id)

	err := s.repo.SoftDeleteProfile(ctx, id)
	if err != nil {
		s.logger.Error("Failed to soft-delete profile", "id", id, "error", err)
		return errors.NewDatabaseError("soft delete profile", err)
	}

	s.logger.Info("Successfully soft-deleted profile", "id", id)
	return nil
}

// VerifyProfile verifies the profile and updates the status to activated
func (s *service) VerifyProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Debug("Starting profile verification", "profile_id", id)

	// Mark the profile as verified
	err := s.repo.VerifyProfile(ctx, id)
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Profile not found for verification", "profile_id", id)
			return errors.NewNotFoundError("profile", map[string]interface{}{"id": id})
		}
		s.logger.Error("Failed to verify profile", "profile_id", id, "error", err)
		return errors.NewDatabaseError("profile verification", err)
	}

	// Update profile status to 'activated'
	err = s.repo.UpdateStatus(ctx, id, StatusActivated)
	if err != nil {
		s.logger.Error("Failed to update profile status after verification", "profile_id", id, "error", err)
		return errors.NewDatabaseError("status update", err)
	}

	s.logger.Info("Profile verified and activated successfully", "profile_id", id)
	return nil
}

// ActivateProfile sets a profile's status to activated
func (s *service) ActivateProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Debug("Activating profile", "profile_id", id)

	err := s.repo.UpdateStatus(ctx, id, StatusActivated)
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Profile not found for activation", "profile_id", id)
			return errors.NewNotFoundError("profile", map[string]interface{}{"id": id})
		}
		s.logger.Error("Failed to activate profile", "profile_id", id, "error", err)
		return errors.NewDatabaseError("profile activation", err)
	}

	s.logger.Info("Profile activated successfully", "profile_id", id)
	return nil
}

// SuspendProfile sets a profile's status to suspended
func (s *service) SuspendProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Debug("Suspending profile", "profile_id", id)

	err := s.repo.UpdateStatus(ctx, id, StatusSuspended)
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Profile not found for suspension", "profile_id", id)
			return errors.NewNotFoundError("profile", map[string]interface{}{"id": id})
		}
		s.logger.Error("Failed to suspend profile", "profile_id", id, "error", err)
		return errors.NewDatabaseError("profile suspension", err)
	}

	s.logger.Info("Profile suspended successfully", "profile_id", id)
	return nil
}

// DeactivateProfile sets a profile's status to inactive
func (s *service) DeactivateProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Debug("Deactivating profile", "profile_id", id)

	err := s.repo.UpdateStatus(ctx, id, StatusDeactivated)
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Profile not found for deactivation", "profile_id", id)
			return errors.NewNotFoundError("profile", map[string]interface{}{"id": id})
		}
		s.logger.Error("Failed to deactivate profile", "profile_id", id, "error", err)
		return errors.NewDatabaseError("profile deactivation", err)
	}

	s.logger.Info("Profile deactivated successfully", "profile_id", id)
	return nil
}

// AuthenticateProfile verifies login credentials and returns the profile if valid
func (s *service) AuthenticateProfile(ctx context.Context, req LoginRequest) (*PlatformProfile, error) {
	var profile *PlatformProfile
	var err error

	s.logger.Debug("Authenticating profile", "username", req.Username, "email", req.Email)

	// Lookup by username or email
	switch {
	case req.Username != "":
		profile, err = s.repo.GetProfileByUsername(ctx, req.Username)
	case req.Email != "":
		profile, err = s.repo.GetProfileByEmail(ctx, req.Email)
	default:
		s.logger.Warn("Username or email not provided")
		return nil, errors.NewValidationError("username or email is required", map[string]any{"field": "username_or_email"})
	}

	// Handle profile lookup errors
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Invalid credentials provided", "username", req.Username, "email", req.Email)
			return nil, errors.NewUnauthorizedError("invalid credentials")
		}
		s.logger.Error("Failed to fetch profile", "error", err)
		return nil, errors.NewDatabaseError("error fetching profile", err)
	}

	// Check profile status before login
	if profile.Status == StatusDeactivated || profile.Status == StatusSuspended {
		s.logger.Warn("Account is not active", "profile_id", profile.ID, "status", profile.Status)
		return nil, errors.NewUnauthorizedError("account is not active")
	}

	// Verify password
	err = bcrypt.CompareHashAndPassword([]byte(profile.PasswordHash), []byte(req.Password))
	if err != nil {
		// Increment failed login attempts
		if errInc := s.repo.IncrementFailedLoginAttempts(ctx, profile.ID); errInc != nil {
			s.logger.Error("Failed to increment failed login attempts", "error", errInc)
		}

		// Check if account should be suspended due to too many failed attempts
		if profile.FailedLoginAttempts+1 >= 5 {
			if errSusp := s.repo.UpdateStatus(ctx, profile.ID, StatusSuspended); errSusp != nil {
				s.logger.Error("Failed to suspend profile after max failed attempts", "error", errSusp)
			}
			s.logger.Warn("Account suspended due to excessive failed login attempts", "profile_id", profile.ID)
			return nil, errors.NewUnauthorizedError("account suspended due to too many failed login attempts")
		}

		s.logger.Warn("Invalid credentials provided", "profile_id", profile.ID)
		return nil, errors.NewUnauthorizedError("invalid credentials")
	}

	// Reset failed attempts on successful login
	if profile.FailedLoginAttempts > 0 {
		if err := s.repo.ResetFailedLoginAttempts(ctx, profile.ID); err != nil {
			s.logger.Warn("Failed to reset failed attempts", "profile_id", profile.ID, "error", err)
		}
	}

	// Update last login timestamp
	if err := s.repo.RecordLogin(ctx, profile.ID); err != nil {
		s.logger.Warn("Failed to record login", "profile_id", profile.ID, "error", err)
	}

	// Activate account if pending on first login
	if profile.Status == StatusPending {
		if err := s.repo.UpdateStatus(ctx, profile.ID, StatusActivated); err != nil {
			s.logger.Warn("Failed to activate pending account", "profile_id", profile.ID, "error", err)
		}
		profile.Status = StatusActivated
		s.logger.Info("Pending account activated upon first login", "profile_id", profile.ID)
	}

	// Remove password hash before returning profile
	profile.PasswordHash = ""
	s.logger.Info("Profile authenticated successfully", "profile_id", profile.ID)
	return profile, nil
}

// ChangePassword changes a user's password when previous password is provided/known
func (s *service) ChangePassword(ctx context.Context, id uuid.UUID, req PasswordChangeRequest) error {
	profile, err := s.repo.GetProfileByID(ctx, id)
	if err != nil {
		return err
	}

	// Verify current password
	err = bcrypt.CompareHashAndPassword([]byte(profile.PasswordHash), []byte(req.CurrentPassword))
	if err != nil {
		return errors.NewUnauthorizedError("current password is incorrect")
	}

	// Ensure new password is different
	if req.CurrentPassword == req.NewPassword {
		return errors.NewValidationError(
			"new password must be different from current password",
			map[string]interface{}{"field": "new_password"},
		)
	}

	// Hash new password
	passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		s.logger.Error("failed to hash password", "error", err)
		return errors.NewBusinessError("PASSWORD_HASHING_FAILED", "failed to update password", nil)
	}

	// Update password in repository
	err = s.repo.UpdatePassword(ctx, id, string(passwordHash))
	if err != nil {
		s.logger.Error("failed to update password in database", "error", err)
		return errors.NewDatabaseError("updating password", err)
	}

	return nil
}

// RequestPasswordReset initiates the password reset process
func (s *service) RequestPasswordReset(ctx context.Context, req PasswordResetRequest) error {
	// Check if profile exists for the given email
	profile, err := s.repo.GetProfileByEmail(ctx, req.Email)
	if err != nil {
		// Do not reveal if email exists or not for security reasons
		s.logger.Info("password reset requested for non-existent email", "email", req.Email)
		return nil
	}

	// Generate reset token
	token, err := s.tokenGenerator.GenerateToken()
	if err != nil {
		s.logger.Error("failed to generate reset token", "error", err)
		return errors.NewBusinessError("RESET_TOKEN_GENERATION_FAILED", "failed to initiate password reset", nil)
	}

	// Store reset token with expiration (1 hours)
	expires := time.Now().Add(1 * time.Hour)

	passwordResetToken := PasswordResetToken{
		ProfileID: profile.ID,
		Token:     token,
		ExpiresAt: expires,
		IsUsed:    false,
		CreatedAt: time.Now(),
	}

	if err := s.repo.CreatePasswordResetToken(ctx, &passwordResetToken); err != nil {
		s.logger.Error("failed to save reset token", "error", err)
		return errors.NewBusinessError("RESET_TOKEN_SAVE_FAILED", "failed to initiate password reset", nil)
	}

	// Send reset link via email
	err = s.mailer.SendPasswordResetEmail(profile.Email, token)
	if err != nil {
		s.logger.Error("failed to send password reset email", "error", err)
		return errors.NewBusinessError("EMAIL_SEND_FAILED", "failed to send password reset email", nil)
	}

	s.logger.Info("password reset token generated and email sent", "profileID", profile.ID, "email", profile.Email)

	return nil
}

// ConfirmPasswordReset validates the reset token and updates the password
func (s *service) ConfirmPasswordReset(ctx context.Context, req PasswordResetConfirmation) error {
	// Validate token
	profile, err := s.repo.GetPasswordResetToken(ctx, req.Token)
	if err != nil {
		return errors.NewDatabaseError("fetching reset token", err)
	}

	// Hash new password
	passwordHash, err := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
	if err != nil {
		s.logger.Error("failed to hash password", "error", err)
		return errors.NewBusinessError(
			"PASSWORD_HASH_FAILED",
			"failed to update password",
			nil,
		)
	}

	// Update password
	if err := s.repo.UpdatePassword(ctx, profile.ProfileID, string(passwordHash)); err != nil {
		return errors.NewBusinessError(
			"PASSWORD_UPDATE_FAILED",
			"failed to update password",
			nil,
		)
	}

	// Mark token as used
	if err := s.repo.MarkPasswordResetTokenUsed(ctx, req.Token); err != nil {
		s.logger.Warn("failed to mark reset token as used", "error", err)
	}

	// Invalidate / Delete all other tokens
	if err := s.repo.DeleteOtherPasswordResetTokens(ctx, profile.ProfileID); err != nil {
		s.logger.Warn("failed to invalidate/delete other reset tokens", "error", err)
	}

	s.logger.Info("password successfully reset and token invalidated", "profileID", profile.ProfileID)
	return nil

}

func (s *service) GetSoftDeletedProfile(ctx context.Context, req GetSoftDeletedProfileRequest) (*PlatformProfile, error) {
	var profile *PlatformProfile
	var err error

	// Check if request contains an email
	if req.Email != nil {
		s.logger.Debug("Fetching soft-deleted profile by email", "email", *req.Email)
		profile, err = s.repo.GetSoftDeletedProfileByEmail(ctx, *req.Email)
		if err == nil && profile != nil {
			s.logger.Info("Soft-deleted profile found by email", "email", *req.Email)
			return profile, nil
		}
		if err != nil {
			s.logger.Warn("Error retrieving soft-deleted profile by email", "email", *req.Email, "error", err)
		}
	}

	// Check if request contains a username (only if email search failed or not provided)
	if req.Username != nil {
		s.logger.Debug("Fetching soft-deleted profile by username", "username", *req.Username)
		profile, err = s.repo.GetSoftDeletedProfileByUsername(ctx, *req.Username)
		if err == nil && profile != nil {
			s.logger.Info("Soft-deleted profile found by username", "username", *req.Username)
			return profile, nil
		}
		if err != nil {
			s.logger.Warn("Error retrieving soft-deleted profile by username", "username", *req.Username, "error", err)
		}
	}

	// Return error if no profile is found after all checks
	s.logger.Warn("Soft-deleted profile not found", "request", req)
	return nil, errors.NewNotFoundError("SoftDeletedProfile", map[string]any{
		"username": req.Username,
		"email":    req.Email,
	})
}

// RestoreProfile restores a soft-deleted profile based on the given identifier (ID, username, or email)
func (s *service) RestoreProfile(ctx context.Context, id uuid.UUID) error {
	var profile *PlatformProfile
	var err error

	s.logger.Debug("Restoring soft-deleted profile by ID", "id", id)

	err = s.repo.RestoreSoftDeletedProfile(ctx, id)

	// Handle errors if the profile is not found or another issue occurs
	if err != nil {
		if errors.IsNotFoundErrorDomain(err) {
			s.logger.Warn("Profile not found in deleted_profiles", "error", err)
			return errors.NewNotFoundError("profile", map[string]interface{}{"id": id})
		}
		s.logger.Error("Failed to get soft-deleted profile", "error", err)
		return errors.NewBusinessError(
			"PROFILE_RESTORE_FAILED",
			"failed to restore profile",
			nil,
		)
	}

	s.logger.Info("Profile restored successfully", "id", profile.ID)
	return nil
}

// HardDeleteProfile hard-deletes a profile
func (s *service) HardDeleteProfile(ctx context.Context, id uuid.UUID) error {
	s.logger.Info("initiating hard delete of profile", "profileID", id)

	err := s.repo.HardDeleteProfile(ctx, id)
	if err != nil {
		s.logger.Error("failed to hard delete profile", "profileID", id, "error", err)
		return errors.NewBusinessError(
			"PROFILE_HARD_DELETE_FAILED",
			"failed to hard delete profile",
			map[string]interface{}{"profileID": id},
		)
	}

	s.logger.Info("profile hard deleted successfully", "profileID", id)
	return nil
}

// AssignRole assigns a role to a profile
func (s *service) AssignRole(ctx context.Context, profileID uuid.UUID, roleID uuid.UUID) error {
	// Verify profile exists
	_, err := s.repo.GetProfileByID(ctx, profileID)
	if err != nil {
		return err
	}

	// Verify role exists
	_, err = s.roleRepo.GetRoleByID(ctx, roleID)
	if err != nil {
		return err
	}

	// Check if already assigned
	hasRole, err := s.repo.HasRoleAssignment(ctx, profileID, roleID)
	if err != nil {
		return err
	}

	if hasRole {
		return errors.NewDomainError("role already assigned to profile", errors.ValidationError)
	}

	return s.repo.AssignRole(ctx, profileID, roleID)
}

// RemoveRole removes a role from a profile
func (s *service) RemoveRole(ctx context.Context, profileID uuid.UUID, roleID uuid.UUID) error {
	// Verify assignment exists
	hasRole, err := s.repo.HasRoleAssignment(ctx, profileID, roleID)
	if err != nil {
		return err
	}

	if !hasRole {
		return errors.NewDomainError("role not assigned to profile", errors.ValidationError)
	}

	return s.repo.RemoveRole(ctx, profileID, roleID)
}

// HasRole checks if a profile has a specific role by name
func (s *service) HasRole(ctx context.Context, profileID uuid.UUID, roleName string) (bool, error) {
	// Get role ID from name
	role, err := s.roleRepo.GetRoleByName(ctx, roleName)
	if err != nil {
		return false, err
	}

	return s.repo.HasRoleAssignment(ctx, profileID, role.ID)
}

// GetPreferences retrieves a profile's preferences
func (s *service) GetPreferences(ctx context.Context, profileID uuid.UUID) (*ProfilePreference, error) {

	// Fetch preferences from the repository
	prefs, err := s.repo.GetPreferences(ctx, profileID)
	if err != nil {
		s.logger.Error("failed to fetch preferences", "profileID", profileID, "error", err)
		return nil, errors.NewDatabaseError("fetching preferences", err)
	}

	s.logger.Info("preferences retrieved successfully", "profileID", profileID)
	return prefs, nil
}

// UpdatePreferences updates a profile's preferences
func (s *service) UpdatePreferences(ctx context.Context, profileID uuid.UUID, prefs ProfilePreference) error {

	s.logger.Info("updating existing preferences", "profileID", profileID)

	if err := s.repo.SavePreferences(ctx, &prefs); err != nil {
		s.logger.Error("failed to update preferences", "profileID", profileID, "error", err)
		return errors.NewBusinessError(
			"PREFERENCES_UPDATE_FAILED",
			"failed to update preferences",
			map[string]interface{}{"profileID": profileID},
		)
	}

	s.logger.Info("preferences updated successfully", "profileID", profileID)
	return nil
}

// SearchProfiles searches for profiles matching a query string
func (s *service) SearchProfiles(ctx context.Context, query string, page, pageSize int) ([]*PlatformProfile, int, error) {
	// Validate pagination parameters
	if page < 1 {
		page = 1
	}
	if pageSize < 1 || pageSize > 100 {
		pageSize = 20 // Default page size
	}

	// Search profiles
	profiles, total, err := s.repo.SearchProfiles(ctx, query, page, pageSize)
	if err != nil {
		return nil, 0, err
	}

	// Remove password hashes from results
	for _, profile := range profiles {
		profile.PasswordHash = ""
	}

	return profiles, total, nil
}

// ListProfilesByRole retrieves profiles that have a specific role
func (s *service) ListProfilesByRole(ctx context.Context, roleID uuid.UUID, page, pageSize int) ([]*PlatformProfile, int, error) {
	// Verify role exists
	_, err := s.roleRepo.GetRoleByID(ctx, roleID)
	if err != nil {
		return nil, 0, err
	}

	// Validate pagination parameters
	if page < 1 {
		page = 1
	}
	if pageSize < 1 || pageSize > 100 {
		pageSize = 20 // Default page size
	}

	// Get profiles by role
	profiles, total, err := s.repo.GetProfilesByRole(ctx, roleID, page, pageSize)
	if err != nil {
		return nil, 0, err
	}

	// Remove password hashes from results
	for _, profile := range profiles {
		profile.PasswordHash = ""
	}

	return profiles, total, nil
}



================================================
File: internal/domain/quiz/model.go
================================================



================================================
File: internal/domain/quiz/repository.go
================================================



================================================
File: internal/domain/quiz/service.go
================================================



================================================
File: internal/domain/quiz/question/base.go
================================================



================================================
File: internal/domain/quiz/question/fill_blank.go
================================================



================================================
File: internal/domain/quiz/question/mcq.go
================================================



================================================
File: internal/domain/quiz/question/true_false.go
================================================



================================================
File: internal/domain/role/model.go
================================================
package role

import (
	"time"
)

// Role represents a role in the system with associated permissions
type Role struct {
	ID          uint         `json:"id"`
	Name        string       `json:"name"`
	Description string       `json:"description"`
	Permissions []Permission `json:"permissions"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
}

// Permission represents an action that can be performed in the system
type Permission struct {
	ID          uint      `json:"id"`
	Resource    string    `json:"resource"` // e.g., "student", "quiz", "event"
	Action      string    `json:"action"`   // e.g., "create", "read", "update", "delete"
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// UserRole represents the relationship between users and roles
type UserRole struct {
	ID        uint      `json:"id"`
	UserID    uint      `json:"user_id"`
	RoleID    uint      `json:"role_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// RolePermission represents the relationship between roles and permissions
type RolePermission struct {
	ID           uint      `json:"id"`
	RoleID       uint      `json:"role_id"`
	PermissionID uint      `json:"permission_id"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
}

// Common predefined roles
const (
	RoleAdmin       = "admin"
	RoleCoordinator = "coordinator"
	RoleStudent     = "student"
	RoleFaculty     = "faculty"
	RoleGuest       = "guest"
)

// Permission actions
const (
	ActionCreate = "create"
	ActionRead   = "read"
	ActionUpdate = "update"
	ActionDelete = "delete"
	ActionManage = "manage" // Special permission for all actions
)



================================================
File: internal/domain/role/repository.go
================================================
package role

import (
	"context"
)

// Repository defines the interface for role data access
type Repository interface {
	// Role operations
	CreateRole(ctx context.Context, role *Role) error
	GetRoleByID(ctx context.Context, id uint) (*Role, error)
	GetRoleByName(ctx context.Context, name string) (*Role, error)
	ListRoles(ctx context.Context) ([]Role, error)
	UpdateRole(ctx context.Context, role *Role) error
	DeleteRole(ctx context.Context, id uint) error

	// Permission operations
	CreatePermission(ctx context.Context, permission *Permission) error
	GetPermissionByID(ctx context.Context, id uint) (*Permission, error)
	ListPermissions(ctx context.Context) ([]Permission, error)
	UpdatePermission(ctx context.Context, permission *Permission) error
	DeletePermission(ctx context.Context, id uint) error

	// Role-Permission operations
	AssignPermissionToRole(ctx context.Context, roleID, permissionID uint) error
	RemovePermissionFromRole(ctx context.Context, roleID, permissionID uint) error
	GetRolePermissions(ctx context.Context, roleID uint) ([]Permission, error)

	// User-Role operations
	AssignRoleToUser(ctx context.Context, userID, roleID uint) error
	RemoveRoleFromUser(ctx context.Context, userID, roleID uint) error
	GetUserRoles(ctx context.Context, userID uint) ([]Role, error)
	GetUsersWithRole(ctx context.Context, roleID uint) ([]uint, error) // Returns user IDs

	// Special queries
	HasPermission(ctx context.Context, userID uint, resource, action string) (bool, error)
}



================================================
File: internal/domain/role/service.go
================================================
package role

import (
	"context"
	"errors"
	"fmt"

	"github.com/google/uuid"
)

// Common errors
var (
	ErrRoleNotFound        = errors.New("role not found")
	ErrPermissionNotFound  = errors.New("permission not found")
	ErrDuplicateRole       = errors.New("role already exists")
	ErrDuplicatePermission = errors.New("permission already exists")
	ErrInvalidRole         = errors.New("invalid role data")
	ErrInvalidPermission   = errors.New("invalid permission data")
	ErrUnauthorized        = errors.New("user does not have required permission")
)

// Service provides role management operations
type Service interface {
	// Role operations
	CreateRole(ctx context.Context, role *Role) error
	GetRoleByID(ctx context.Context, id uint) (*Role, error)
	GetRoleByName(ctx context.Context, name string) (*Role, error)
	ListRoles(ctx context.Context) ([]Role, error)
	UpdateRole(ctx context.Context, role *Role) error
	DeleteRole(ctx context.Context, id uint) error

	// Permission operations
	CreatePermission(ctx context.Context, permission *Permission) error
	GetPermissionByID(ctx context.Context, id uint) (*Permission, error)
	ListPermissions(ctx context.Context) ([]Permission, error)
	UpdatePermission(ctx context.Context, permission *Permission) error
	DeletePermission(ctx context.Context, id uint) error

	// Role-Permission operations
	AssignPermissionToRole(ctx context.Context, roleID, permissionID uint) error
	RemovePermissionFromRole(ctx context.Context, roleID, permissionID uint) error
	GetRolePermissions(ctx context.Context, roleID uint) ([]Permission, error)
	GetDefaultRoleID(ctx context.Context) (uuid.UUID, error)

	// User-Role operations
	AssignRoleToUser(ctx context.Context, userID, roleID uint) error
	RemoveRoleFromUser(ctx context.Context, userID, roleID uint) error
	GetUserRoles(ctx context.Context, userID uint) ([]Role, error)

	// Permission checking
	HasPermission(ctx context.Context, userID uint, resource, action string) (bool, error)
	Authorize(ctx context.Context, userID uint, resource, action string) error

	// Bulk operations
	SyncUserRoles(ctx context.Context, userID uint, roleIDs []uint) error
	SyncRolePermissions(ctx context.Context, roleID uint, permissionIDs []uint) error
}

// service implements the Service interface
type service struct {
	repo Repository
}

// NewService creates a new role service
func NewService(repo Repository) Service {
	return &service{
		repo: repo,
	}
}

// GetDefaultRoleID returns the ID of the default role for new profiles
func (s *service) GetDefaultRoleID(ctx context.Context) (uint, error) {
	// Get the role with the default role name (e.g., "guest")
	defaultRole, err := s.repo.GetRoleByName(ctx, "guest") // Or whatever your default role is called
	if err != nil {
		return 0, fmt.Errorf("failed to fetch default role: %w", err)
	}

	if defaultRole == nil {
		return 0, errors.New("default role does not exist")
	}

	return defaultRole.ID, nil
}

// Implementation of Service interface methods

func (s *service) CreateRole(ctx context.Context, role *Role) error {
	// Validate role
	if role.Name == "" {
		return ErrInvalidRole
	}

	// Check for duplicate
	existing, err := s.repo.GetRoleByName(ctx, role.Name)
	if err == nil && existing != nil {
		return ErrDuplicateRole
	}

	return s.repo.CreateRole(ctx, role)
}

func (s *service) GetRoleByID(ctx context.Context, id uint) (*Role, error) {
	return s.repo.GetRoleByID(ctx, id)
}

func (s *service) GetRoleByName(ctx context.Context, name string) (*Role, error) {
	return s.repo.GetRoleByName(ctx, name)
}

func (s *service) ListRoles(ctx context.Context) ([]Role, error) {
	return s.repo.ListRoles(ctx)
}

func (s *service) UpdateRole(ctx context.Context, role *Role) error {
	// Validate role
	if role.Name == "" {
		return ErrInvalidRole
	}

	// Ensure role exists
	existing, err := s.repo.GetRoleByID(ctx, role.ID)
	if err != nil {
		return err
	}
	if existing == nil {
		return ErrRoleNotFound
	}

	return s.repo.UpdateRole(ctx, role)
}

func (s *service) DeleteRole(ctx context.Context, id uint) error {
	// Ensure role exists
	existing, err := s.repo.GetRoleByID(ctx, id)
	if err != nil {
		return err
	}
	if existing == nil {
		return ErrRoleNotFound
	}

	return s.repo.DeleteRole(ctx, id)
}

// Authorization logic
func (s *service) HasPermission(ctx context.Context, userID uint, resource, action string) (bool, error) {
	return s.repo.HasPermission(ctx, userID, resource, action)
}

func (s *service) Authorize(ctx context.Context, userID uint, resource, action string) error {
	hasPermission, err := s.HasPermission(ctx, userID, resource, action)
	if err != nil {
		return err
	}
	if !hasPermission {
		return ErrUnauthorized
	}
	return nil
}

// Implement other service methods...



================================================
File: internal/domain/student/model.go
================================================
// internal/domain/student/model.go

package student

import (
	"time"

	"github.com/google/uuid"
)

// Student represents the core student entity in the system
type Student struct {
	// ID            uuid.UUID     `json:"id"`
	EnrollmentID  string        `json:"enrollment_id"` // University enrollment ID/number
	FirstName     string        `json:"first_name"`
	LastName      string        `json:"last_name"`
	Email         string        `json:"email"`
	PhoneNumber   string        `json:"phone_number"`
	DateOfBirth   time.Time     `json:"date_of_birth"`
	Gender        string        `json:"gender"`
	PresentAddress       Address       `json:"present_address"`
	PermanentAddress Address `json:"permanent_address"`

	Program       string        `json:"program"` // Degree program (e.g., "B.Tech Computer Science")
	Batch         string        `json:"batch"`   // Admission year/batch (e.g., "2023-2027")
	
	PresentSemester      int           `json:"semester"` // Set to 10 for pass outs
	Section       string        `json:"section,omitempty"` // Can be empty
	Status        StudentStatus `json:"status"`
	ProfileImageUrl  string        `json:"profile_image_url"`
	
	// Achievements  []Achievement `json:"achievements,omitempty"`
	// Courses       []Course      `json:"courses,omitempty"`

	RoleIDs       []uuid.UUID   `json:"role_ids,omitempty"` // Link to roles in role domain
	PasswordHash  string        `json:"-"`                  // Never exposed in JSON
	LastLoginAt   *time.Time    `json:"last_login_at,omitempty"`
	CreatedAt     time.Time     `json:"created_at"`
	UpdatedAt     time.Time     `json:"updated_at"`
	DeactivatedAt *time.Time    `json:"deactivated_at,omitempty"`
}

// Address represents a student's address
type Address struct {
	Street     string `json:"street,omitempty"`
	City       string `json:"city,omitempty"`
	State      string `json:"state,omitempty"`
	PostalCode string `json:"postal_code,omitempty"`
	Country    string `json:"country,omitempty"`
}

// Achievement represents student achievements, certifications, or awards
// type Achievement struct {
// 	ID          uuid.UUID `json:"id"`
// 	Title       string    `json:"title"`
// 	Description string    `json:"description,omitempty"`
// 	IssuedBy    string    `json:"issued_by,omitempty"`
// 	IssuedDate  time.Time `json:"issued_date"`
// 	ExpiryDate  *time.Time `json:"expiry_date,omitempty"`
// 	Certificate string    `json:"certificate,omitempty"` // File path or URL to certificate
// 	CreatedAt   time.Time `json:"created_at"`
// 	UpdatedAt   time.Time `json:"updated_at"`
// }

// // Course represents a course that a student is enrolled in
// type Course struct {
// 	ID           uuid.UUID  `json:"id"`
// 	CourseCode   string     `json:"course_code"`
// 	Name         string     `json:"name"`
// 	Credits      float64    `json:"credits"`
// 	Semester     int        `json:"semester"`
// 	Grade        string     `json:"grade,omitempty"`
// 	AttendanceID *uuid.UUID `json:"attendance_id,omitempty"` // Link to attendance records
// 	EnrolledAt   time.Time  `json:"enrolled_at"`
// }

// StudentStatus represents the current status of a student
type StudentStatus string

// Possible student statuses
const (
	StatusActive       StudentStatus = "active"
	StatusOnLeave      StudentStatus = "on_leave"
	StatusGraduated    StudentStatus = "graduated"
	StatusSuspended    StudentStatus = "suspended"
	StatusDeactivated  StudentStatus = "deactivated"
	StatusProvisional  StudentStatus = "provisional"
)

// StudentAttendance represents attendance records for a student
type StudentAttendance struct {
	ID         uuid.UUID            `json:"id"`
	StudentID  uuid.UUID            `json:"student_id"`
	CourseID   uuid.UUID            `json:"course_id"`
	Semester   int                  `json:"semester"`
	Records    []AttendanceRecord   `json:"records"`
	Statistics AttendanceStatistics `json:"statistics"`
	CreatedAt  time.Time            `json:"created_at"`
	UpdatedAt  time.Time            `json:"updated_at"`
}

// AttendanceRecord represents a single attendance entry
type AttendanceRecord struct {
	Date     time.Time      `json:"date"`
	Status   AttendanceType `json:"status"`
	Remarks  string         `json:"remarks,omitempty"`
	RecordedBy uuid.UUID    `json:"recorded_by"` // ID of coordinator/faculty who marked attendance
}

// AttendanceType represents the status of attendance for a class
type AttendanceType string

// Possible attendance types
const (
	AttendancePresent AttendanceType = "present"
	AttendanceAbsent  AttendanceType = "absent"
	AttendanceLeave   AttendanceType = "leave"
)

// AttendanceStatistics represents calculated attendance metrics
type AttendanceStatistics struct {
	TotalClasses   int     `json:"total_classes"`
	Present        int     `json:"present"`
	Absent         int     `json:"absent"`
	Leave          int     `json:"leave"`
	AttendanceRate float64 `json:"attendance_rate"` // Percentage
}

// StudentPreferences represents a student's preferences and settings
type StudentPreferences struct {
	ID                 uuid.UUID `json:"id"`
	StudentID          uuid.UUID `json:"student_id"`
	Calendar           Calendar  `json:"calendar"`
	CreatedAt          time.Time `json:"created_at"`
	UpdatedAt          time.Time `json:"updated_at"`
}

// Calendar represents calendar sync preferences
type Calendar struct {
	Enabled    bool   `json:"enabled"`
	Provider   string `json:"provider,omitempty"` // e.g., "google", "outlook"
	ExternalID string `json:"external_id,omitempty"`
}

// StudentContact represents a student's emergency contact information
type StudentContact struct {
	ID         uuid.UUID `json:"id"`
	StudentID  uuid.UUID `json:"student_id"`
	Name       string    `json:"name"`
	Relation   string    `json:"relation"`
	Phone      string    `json:"phone"`
	Email      string    `json:"email,omitempty"`
	IsEmergency bool      `json:"is_emergency"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}



// NewStudent creates a new student instance with default values
func NewStudent(enrollmentID, firstName, lastName, email, program, batch string, semester int) *Student {
	now := time.Now()
	return &Student{
		// ID:           uuid.New(),
		EnrollmentID: enrollmentID,
		FirstName:    firstName,
		LastName:     lastName,
		Email:        email,
		Program:      program,
		Batch:        batch,
		PresentSemester:     semester,
		Status:       StatusActive,
		CreatedAt:    now,
		UpdatedAt:    now,
	}
}

// FullName returns the student's full name
func (s *Student) FullName() string {
	return s.FirstName + " " + s.LastName
}

// IsActive checks if the student is currently active
func (s *Student) IsActive() bool {
	return s.Status == StatusActive && s.DeactivatedAt == nil
}

// HasRole checks if the student has a specific role
func (s *Student) HasRole(roleID uuid.UUID) bool {
	for _, id := range s.RoleIDs {
		if id == roleID {
			return true
		}
	}
	return false
}

// // AddCourse adds a course to the student's enrollment
// func (s *Student) AddCourse(course Course) {
// 	s.Courses = append(s.Courses, course)
// 	s.UpdatedAt = time.Now()
// }

// GetAttendanceRate calculates the overall attendance rate across all courses
func (s *Student) GetAttendanceRate() float64 {
	// This would typically be calculated from attendance records
	// This is a simplified placeholder
	return 0.0
}

// Deactivate sets the student's status to deactivated
func (s *Student) Deactivate() {
	now := time.Now()
	s.Status = StatusDeactivated
	s.DeactivatedAt = &now
	s.UpdatedAt = now
}


================================================
File: internal/domain/student/repository.go
================================================
// internal/domain/student/repository.go

package student

import (
	"context"

	"github.com/google/uuid"
)

// Repository defines the data access contract for students
type Repository interface {
	// Create creates a new student
	Create(ctx context.Context, student *Student) error

	// GetByID retrieves a student by ID
	GetByID(ctx context.Context, id uuid.UUID) (*Student, error)

	// GetByEnrollmentID retrieves a student by enrollment ID
	GetByEnrollmentID(ctx context.Context, enrollmentID string) (*Student, error)

	// GetByEmail retrieves a student by email
	GetByEmail(ctx context.Context, email string) (*Student, error)

	// Update updates an existing student
	Update(ctx context.Context, student *Student) error

	// Delete deletes a student by ID
	Delete(ctx context.Context, id uuid.UUID) error

	// List retrieves students with pagination
	List(ctx context.Context, filter StudentFilter, pagination Pagination) ([]*Student, int64, error)

	// AddCourse adds a course to a student
	// AddCourse(ctx context.Context, studentID uuid.UUID, course Course) error

	// RemoveCourse removes a course from a student
	RemoveCourse(ctx context.Context, studentID uuid.UUID, courseID uuid.UUID) error

	// UpdateCourseGrade updates a grade for a specific course
	UpdateCourseGrade(ctx context.Context, studentID, courseID uuid.UUID, grade string) error

	// GetAttendance retrieves attendance for a student
	GetAttendance(ctx context.Context, studentID uuid.UUID, courseID *uuid.UUID, semester *int) ([]StudentAttendance, error)

	// RecordAttendance records attendance for a student
	RecordAttendance(ctx context.Context, attendance *StudentAttendance) error

	// GetPreferences retrieves preferences for a student
	GetPreferences(ctx context.Context, studentID uuid.UUID) (*StudentPreferences, error)

	// UpdatePreferences updates preferences for a student
	UpdatePreferences(ctx context.Context, preferences *StudentPreferences) error

	// GetContacts retrieves contacts for a student
	GetContacts(ctx context.Context, studentID uuid.UUID) ([]StudentContact, error)

	// AddContact adds a contact for a student
	AddContact(ctx context.Context, contact *StudentContact) error

	// UpdateContact updates a contact for a student
	UpdateContact(ctx context.Context, contact *StudentContact) error

	// DeleteContact deletes a contact for a student
	DeleteContact(ctx context.Context, contactID uuid.UUID) error

	// CreateSession creates a new session for a student
	// CreateSession(ctx context.Context, session *StudentSession) error

	// GetActiveSession retrieves an active session by token
	// GetActiveSession(ctx context.Context, token string) (*StudentSession, error)

	// RevokeSession revokes a session
	RevokeSession(ctx context.Context, sessionID uuid.UUID) error

	// AddAchievement adds an achievement to a student
	// AddAchievement(ctx context.Context, studentID uuid.UUID, achievement Achievement) error

	// GetAchievements retrieves achievements for a student
	// GetAchievements(ctx context.Context, studentID uuid.UUID) ([]Achievement, error)
}

// StudentFilter defines the filter options for listing students
type StudentFilter struct {
	Status      *StudentStatus
	Program     *string
	Batch       *string
	Semester    *int
	SearchQuery *string // Will match against name, email, or enrollment ID
}

// Pagination defines the pagination options
type Pagination struct {
	Page     int
	PageSize int
	SortBy   string
	SortDesc bool
}


================================================
File: internal/domain/student/service.go
================================================
// internal/domain/student/service.go

package student

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// Common errors
var (
	ErrStudentNotFound      = errors.New("student not found")
	ErrEmailAlreadyExists   = errors.New("email already exists")
	ErrEnrollmentIDExists   = errors.New("enrollment ID already exists")
	ErrInvalidCredentials   = errors.New("invalid credentials")
	ErrInvalidStatus        = errors.New("invalid status")
	ErrInvalidEmail         = errors.New("invalid email format")
	ErrInvalidEnrollmentID  = errors.New("invalid enrollment ID format")
	ErrInvalidPasswordStrength = errors.New("password does not meet strength requirements")
)

// Service provides student-related operations
type Service struct {
	repo Repository
	// Add other necessary dependencies like event publisher, logger, etc.
	// eventPublisher eventbus.Publisher
	// logger         logger.Logger
}

// NewService creates a new instance of the student service
func NewService(repo Repository) *Service {
	return &Service{
		repo: repo,
	}
}

// Register registers a new student in the system
func (s *Service) Register(ctx context.Context, student *Student, password string) (*Student, error) {
	// Validate email format
	if !isValidEmail(student.Email) {
		return nil, ErrInvalidEmail
	}

	// Validate enrollment ID format
	if !isValidEnrollmentID(student.EnrollmentID) {
		return nil, ErrInvalidEnrollmentID
	}

	// Check if email already exists
	existingStudent, err := s.repo.GetByEmail(ctx, student.Email)
	if err == nil && existingStudent != nil {
		return nil, ErrEmailAlreadyExists
	}

	// Check if enrollment ID already exists
	existingStudent, err = s.repo.GetByEnrollmentID(ctx, student.EnrollmentID)
	if err == nil && existingStudent != nil {
		return nil, ErrEnrollmentIDExists
	}

	// Validate password strength
	if !isPasswordStrong(password) {
		return nil, ErrInvalidPasswordStrength
	}

	// Hash password
	hashedPassword, err := hashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Set default values
	if student.ID == uuid.Nil {
		student.ID = uuid.New()
	}
	student.PasswordHash = hashedPassword
	student.Status = StatusActive
	now := time.Now()
	student.CreatedAt = now
	student.UpdatedAt = now

	// Save student to repository
	if err := s.repo.Create(ctx, student); err != nil {
		return nil, fmt.Errorf("failed to create student: %w", err)
	}

	// Publish student created event
	// s.eventPublisher.Publish("student.created", student)

	return student, nil
}

// Authenticate authenticates a student with email and password
func (s *Service) Authenticate(ctx context.Context, email, password string) (*Student, error) {
	student, err := s.repo.GetByEmail(ctx, email)
	if err != nil || student == nil {
		return nil, ErrInvalidCredentials
	}

	// Check if student is active
	if !student.IsActive() {
		return nil, ErrInvalidCredentials
	}

	// Verify password
	if err := verifyPassword(student.PasswordHash, password); err != nil {
		return nil, ErrInvalidCredentials
	}

	// Update last login time
	now := time.Now()
	student.LastLoginAt = &now
	student.UpdatedAt = now
	if err := s.repo.Update(ctx, student); err != nil {
		return nil, fmt.Errorf("failed to update last login time: %w", err)
	}

	return student, nil
}

// GetByID retrieves a student by ID
func (s *Service) GetByID(ctx context.Context, id uuid.UUID) (*Student, error) {
	student, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, ErrStudentNotFound
	}
	return student, nil
}

// GetByEnrollmentID retrieves a student by enrollment ID
func (s *Service) GetByEnrollmentID(ctx context.Context, enrollmentID string) (*Student, error) {
	student, err := s.repo.GetByEnrollmentID(ctx, enrollmentID)
	if err != nil {
		return nil, ErrStudentNotFound
	}
	return student, nil
}

// Update updates a student's profile
func (s *Service) Update(ctx context.Context, student *Student) (*Student, error) {
	existingStudent, err := s.repo.GetByID(ctx, student.ID)
	if err != nil {
		return nil, ErrStudentNotFound
	}

	// Prevent updating critical fields
	student.EnrollmentID = existingStudent.EnrollmentID
	student.Email = existingStudent.Email
	student.PasswordHash = existingStudent.PasswordHash
	student.CreatedAt = existingStudent.CreatedAt
	student.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, student); err != nil {
		return nil, fmt.Errorf("failed to update student: %w", err)
	}

	return student, nil
}

// UpdateEmail updates a student's email
func (s *Service) UpdateEmail(ctx context.Context, studentID uuid.UUID, newEmail string) error {
	if !isValidEmail(newEmail) {
		return ErrInvalidEmail
	}

	// Check if email already exists
	existingStudent, err := s.repo.GetByEmail(ctx, newEmail)
	if err == nil && existingStudent != nil && existingStudent.ID != studentID {
		return ErrEmailAlreadyExists
	}

	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	student.Email = newEmail
	student.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, student); err != nil {
		return fmt.Errorf("failed to update email: %w", err)
	}

	// Publish email updated event
	// s.eventPublisher.Publish("student.email_updated", student)

	return nil
}

// ChangePassword changes a student's password
func (s *Service) ChangePassword(ctx context.Context, studentID uuid.UUID, currentPassword, newPassword string) error {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Verify current password
	if err := verifyPassword(student.PasswordHash, currentPassword); err != nil {
		return ErrInvalidCredentials
	}

	// Validate password strength
	if !isPasswordStrong(newPassword) {
		return ErrInvalidPasswordStrength
	}

	// Hash new password
	hashedPassword, err := hashPassword(newPassword)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	student.PasswordHash = hashedPassword
	student.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, student); err != nil {
		return fmt.Errorf("failed to update password: %w", err)
	}

	// Revoke all sessions for security
	// TODO: Implement session revocation logic

	return nil
}

// UpdateStatus updates a student's status
func (s *Service) UpdateStatus(ctx context.Context, studentID uuid.UUID, status StudentStatus) error {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Validate status
	if !isValidStatus(status) {
		return ErrInvalidStatus
	}

	student.Status = status
	student.UpdatedAt = time.Now()

	if status == StatusDeactivated {
		now := time.Now()
		student.DeactivatedAt = &now
	}

	if err := s.repo.Update(ctx, student); err != nil {
		return fmt.Errorf("failed to update status: %w", err)
	}

	// Publish status updated event
	// s.eventPublisher.Publish("student.status_updated", student)

	return nil
}

// ListStudents retrieves a list of students with filtering and pagination
func (s *Service) ListStudents(ctx context.Context, filter StudentFilter, pagination Pagination) ([]*Student, int64, error) {
	return s.repo.List(ctx, filter, pagination)
}

// EnrollCourse enrolls a student in a course
func (s *Service) EnrollCourse(ctx context.Context, studentID uuid.UUID, course Course) error {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Check if student is already enrolled in the course
	for _, existingCourse := range student.Courses {
		if existingCourse.CourseCode == course.CourseCode {
			return errors.New("student already enrolled in this course")
		}
	}

	// Set default values
	course.ID = uuid.New()
	course.EnrolledAt = time.Now()

	return s.repo.AddCourse(ctx, studentID, course)
}

// UnenrollCourse removes a student from a course
func (s *Service) UnenrollCourse(ctx context.Context, studentID, courseID uuid.UUID) error {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Check if student is enrolled in the course
	found := false
	for _, course := range student.Courses {
		if course.ID == courseID {
			found = true
			break
		}
	}

	if !found {
		return errors.New("student not enrolled in this course")
	}

	return s.repo.RemoveCourse(ctx, studentID, courseID)
}

// UpdateCourseGrade updates a student's grade for a specific course
func (s *Service) UpdateCourseGrade(ctx context.Context, studentID, courseID uuid.UUID, grade string) error {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Check if student is enrolled in the course
	found := false
	for _, course := range student.Courses {
		if course.ID == courseID {
			found = true
			break
		}
	}

	if !found {
		return errors.New("student not enrolled in this course")
	}

	// Validate grade format
	if !isValidGrade(grade) {
		return errors.New("invalid grade format")
	}

	return s.repo.UpdateCourseGrade(ctx, studentID, courseID, grade)
}

// GetAttendance retrieves attendance records for a student
func (s *Service) GetAttendance(ctx context.Context, studentID uuid.UUID, courseID *uuid.UUID, semester *int) ([]StudentAttendance, error) {
	_, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return nil, ErrStudentNotFound
	}

	return s.repo.GetAttendance(ctx, studentID, courseID, semester)
}

// RecordAttendance records attendance for a student
func (s *Service) RecordAttendance(ctx context.Context, attendance *StudentAttendance) error {
	_, err := s.repo.GetByID(ctx, attendance.StudentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Validate attendance record
	if attendance.ID == uuid.Nil {
		attendance.ID = uuid.New()
	}
	attendance.CreatedAt = time.Now()
	attendance.UpdatedAt = time.Now()

	// Calculate statistics
	calculateAttendanceStatistics(attendance)

	return s.repo.RecordAttendance(ctx, attendance)
}

// GetPreferences retrieves preferences for a student
func (s *Service) GetPreferences(ctx context.Context, studentID uuid.UUID) (*StudentPreferences, error) {
	_, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return nil, ErrStudentNotFound
	}

	return s.repo.GetPreferences(ctx, studentID)
}

// UpdatePreferences updates preferences for a student
func (s *Service) UpdatePreferences(ctx context.Context, preferences *StudentPreferences) error {
	_, err := s.repo.GetByID(ctx, preferences.StudentID)
	if err != nil {
		return ErrStudentNotFound
	}

	preferences.UpdatedAt = time.Now()
	return s.repo.UpdatePreferences(ctx, preferences)
}

// AddAchievement adds an achievement to a student
func (s *Service) AddAchievement(ctx context.Context, studentID uuid.UUID, achievement Achievement) error {
	_, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return ErrStudentNotFound
	}

	// Set default values
	if achievement.ID == uuid.Nil {
		achievement.ID = uuid.New()
	}
	achievement.CreatedAt = time.Now()
	achievement.UpdatedAt = time.Now()

	return s.repo.AddAchievement(ctx, studentID, achievement)
}

// GetAchievements retrieves achievements for a student
func (s *Service) GetAchievements(ctx context.Context, studentID uuid.UUID) ([]Achievement, error) {
	_, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return nil, ErrStudentNotFound
	}

	return s.repo.GetAchievements(ctx, studentID)
}

// CreateSession creates a new session for a student
func (s *Service) CreateSession(ctx context.Context, studentID uuid.UUID, userAgent, ipAddress string) (*StudentSession, error) {
	student, err := s.repo.GetByID(ctx, studentID)
	if err != nil {
		return nil, ErrStudentNotFound
	}

	if !student.IsActive() {
		return nil, errors.New("inactive student cannot create session")
	}

	// Generate tokens
	token := generateToken(student.ID)
	refreshToken := generateRefreshToken()

	// Create session
	session := &StudentSession{
		ID:           uuid.New(),
		StudentID:    studentID,
		Token:        token,
		RefreshToken: refreshToken,
		UserAgent:    userAgent,
		IPAddress:    ipAddress,
		ExpiresAt:    time.Now().Add(24 * time.Hour), // Token expires in 24 hours
		CreatedAt:    time.Now(),
	}

	if err := s.repo.CreateSession(ctx, session); err != nil {
		return nil, fmt.Errorf("failed to create session: %w", err)
	}

	return session, nil
}

// RevokeSession revokes a session
func (s *Service) RevokeSession(ctx context.Context, sessionID uuid.UUID) error {
	return s.repo.RevokeSession(ctx, sessionID)
}

// Helper functions

// isValidEmail validates email format
func isValidEmail(email string) bool {
	// Simple validation, can be expanded with regex
	return strings.Contains(email, "@") && strings.Contains(email, ".")
}


// isValidEnrollmentID validates enrollment ID format
func isValidEnrollmentID(enrollmentID string) bool {
	// This can be expanded with specific validation logic based on your university's enrollment ID format
	return len(enrollmentID) >= 5 && len(enrollmentID) <= 15
}

// isPasswordStrong validates password strength
func isPasswordStrong(password string) bool {
	// Password must be at least 8 characters, contain uppercase, lowercase, number, and special character
	if len(password) < 8 {
		return false
	}

	hasUpper := false
	hasLower := false
	hasNumber := false
	hasSpecial := false

	for _, char := range password {
		switch {
		case 'A' <= char && char <= 'Z':
			hasUpper = true
		case 'a' <= char && char <= 'z':
			hasLower = true
		case '0' <= char && char <= '9':
			hasNumber = true
		case strings.ContainsRune("!@#$%^&*()-_=+[]{}|;:'\",.<>/?", char):
			hasSpecial = true
		}
	}

	return hasUpper && hasLower && hasNumber && hasSpecial
}

// isValidStatus validates student status
func isValidStatus(status StudentStatus) bool {
	validStatuses := []StudentStatus{
		StatusActive,
		StatusOnLeave,
		StatusGraduated,
		StatusSuspended,
		StatusDeactivated,
		StatusProvisional,
	}

	for _, s := range validStatuses {
		if status == s {
			return true
		}
	}
	return false
}

// isValidGrade validates grade format
func isValidGrade(grade string) bool {
	validGrades := []string{"A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D+", "D", "F", "I", "W"}
	for _, g := range validGrades {
		if grade == g {
			return true
		}
	}
	return false
}

// hashPassword hashes a password using bcrypt
func hashPassword(password string) (string, error) {
	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedBytes), nil
}

// verifyPassword verifies a password against its hash
func verifyPassword(hashedPassword, password string) error {
	return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}

// generateToken generates a JWT token for a student
func generateToken(studentID uuid.UUID) string {
	// This would typically use a JWT library to generate a proper token
	// Placeholder implementation
	return fmt.Sprintf("token_%s_%d", studentID.String(), time.Now().Unix())
}

// generateRefreshToken generates a refresh token
func generateRefreshToken() string {
	// This would typically generate a cryptographically secure random token
	// Placeholder implementation
	return fmt.Sprintf("refresh_%d", time.Now().UnixNano())
}

// calculateAttendanceStatistics calculates statistics for attendance records
func calculateAttendanceStatistics(attendance *StudentAttendance) {
	var present, absent, leave int
	
	for _, record := range attendance.Records {
		switch record.Status {
		case AttendancePresent:
			present++
		case AttendanceAbsent:
			absent++
		case AttendanceLeave:
			leave++
		}
	}
	
	totalClasses := present + absent + leave
	var attendanceRate float64
	if totalClasses > 0 {
		attendanceRate = float64(present) / float64(totalClasses) * 100
	}
	
	attendance.Statistics = AttendanceStatistics{
		TotalClasses:   totalClasses,
		Present:        present,
		Absent:         absent,
		Leave:          leave,
		AttendanceRate: attendanceRate,
	}
}


================================================
File: internal/domain/student/student/enrollment_master_lookup_table.go
================================================
// Most Dependent Table
// References to all other tables and used to fetch all details of a student in one go.
// Receiving all the Traffic for lookups.
// The certification related information is stored separately in the Certifications lookup table.
// The leaderboard and practice session records must be looked in respective separate dedicated
// lookup tables.
package student

type EnrollmentMasterLookupTable struct {
	EnrollmentNo         string `gorm:"type:varchar(12);size:12;primaryKey;check:char_length(enrollment_no) = 12" json:"enrollmentNo"` // Enrollment number (Primary Key)
	LogInDetailsID       uint32 `gorm:"not null;unique" json:"-" bson:"-"`                                                             // Reference to login details table id for student (uint32)
	AcademicDetailsID    uint32 `gorm:"not null;unique" json:"-" bson:"-"`                                                             // Reference to academic details table id for student (uint32)
	FamilyDetailsID      uint32 `gorm:"not null;unique" json:"-" bson:"-"`                                                             // Reference to family details table id for student (uint32)
	ProfileDetailsID     uint32 `gorm:"not null;unique" json:"-" bson:"-"`                                                             // Reference to profile details table id for student (uint32)
	ScholarshipDetailsID uint32 `gorm:"not null;unique" json:"-" bson:"-"`                                                             // Reference to scholarship details table id for student (uint32)

	// Foreign keys to maintain referential integrity
	StudentLogInDetailsTable StudentLogInDetailsTable       `gorm:"foreignKey:LogInDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE" json:"-" bson:"-"`
	AcademicDetails          StudentAcademicDetailsTable    `gorm:"foreignKey:AcademicDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE" json:"-" bson:"-"`
	FamilyDetails            StudentFamilyDetailsTable      `gorm:"foreignKey:FamilyDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE" json:"-" bson:"-"`
	ProfileDetails           StudentProfileDetailsTable     `gorm:"foreignKey:ProfileDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE" json:"-" bson:"-"`
	ScholarshipDetails       StudentScholarshipDetailsTable `gorm:"foreignKey:ScholarshipDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE" json:"-" bson:"-"`
}

func (EnrollmentMasterLookupTable) TableName() string {
	return "public.enrollment_master_lookup_table"
}



================================================
File: internal/domain/student/student/leaderboard_lookup_table.go
================================================
package student

type StudentLeaderboardLookupTable struct {
	EnrollmentNo        string `gorm:"type:varchar(12);size:12;not null" json:"enrollmentNo"` // FK to student
	LeaderboardRecordID uint32 `gorm:"primaryKey;not null" json:"leaderboardRecordID"`        // FK to leaderboard record

	// Foreign key relationships
	LeaderboardRecord StudentLeaderboardRecordTable `gorm:"foreignKey:LeaderboardRecordID;references:LeaderboardRecordID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (StudentLeaderboardLookupTable) TableName() string {
	return "student_schema.student_leaderboard_lookup_table"
}



================================================
File: internal/domain/student/student/leaderboard_table.go
================================================
// This is an independent table to store leaderboard related information.
package student

import (
	"time"
)

type StudentLeaderboardRecordTable struct {
	// LeaderboardRecordID = Unique identifier for each leaderboard record
	LeaderboardRecordID uint32 `gorm:"primaryKey;autoIncrement" json:"-" bson:"-"`

	// Rank = Position of the student in the leaderboard
	Rank int `gorm:"not null" json:"rank" bson:"rank" binding:"required"`

	// Score = Total score obtained by the student
	Score float64 `gorm:"not null" json:"score" bson:"score" binding:"required"` // Float allows partial marking

	// Domain = Category of the questions (e.g., Programming, Mathematics)
	Domain string `gorm:"type:varchar(100);not null" json:"domain" bson:"domain" binding:"required"`

	// SubDomain = Sub-category of the questions (e.g., Data Structures, Algebra)
	SubDomain string `gorm:"type:varchar(100);not null" json:"subDomain" bson:"subDomain" binding:"required"`

	// TimePeriod = Time duration for which the leaderboard is valid (e.g., weekly, monthly)
	TimePeriod string `gorm:"type:varchar(7);not null" json:"timePeriod" bson:"timePeriod" binding:"required"`

	// LastUpdated = Timestamp of the last update to the leaderboard record
	LastUpdated time.Time `gorm:"type:timestamp with time zone;autoUpdateTime" json:"lastUpdated" bson:"lastUpdated"`
}

// TableName returns the name of the table in the database
func (StudentLeaderboardRecordTable) TableName() string {
	return "student_schema.student_leaderboard_records_table"
}



================================================
File: internal/domain/student/student/student_academic_details.go
================================================
// This file contains the model for the
// student_academic_details_table table in the student_schema of the PostgreSQL database.
// Contains all the details related to the academic performance of a student.
// Holds reference to the documents table for the marksheet documents.
package student

import (
	"time"
)

type StudentAcademicDetailsTable struct {
	// ID = Primary Key (unique identifier for each student).
	// To be used internally only. Not to be sent in responses.
	ID uint32 `gorm:"primaryKey;autoIncrement" json:"-" bson:"-"`

	// Branch = Short name for the student's branch, e.g., "CSE", "ECE".
	Branch string `gorm:"type:varchar(7);not null" json:"branch" binding:"required" bson:"branch"`

	// Year of Enrollment = Year the student enrolled, restricted to the range [1990-2100].
	YearOfEnrollment int `gorm:"check:year_of_enrollment BETWEEN 1990 AND 2100;not null" json:"yearOfEnrollment" binding:"required" bson:"yearOfEnrollment"`

	// CGPA = Cumulative Grade Point Average of the student.
	CGPA float32 `gorm:"type:real" json:"cgpa" binding:"gte=0,lte=10" bson:"cgpa"`

	// PreviousSemSGPA = SGPA of the last semester completed.
	PreviousSemSGPA float32 `gorm:"type:real" json:"previousSemSgpa" binding:"gte=0,lte=10" bson:"previousSemSgpa"`

	// School for Class Ten
	SchoolForClassTen string `gorm:"type:varchar(255)" json:"schoolForClassTen" binding:"required" bson:"schoolForClassTen"`

	// Class Ten Percentage
	ClassTenPercentage float32 `gorm:"type:real" json:"classTenPercentage" binding:"gte=0,lte=100" bson:"classTenPercentage"`

	// Class Ten Marksheet Document ID = Foreign key to Documents table.
	ClassTenMarksheetID uint32 `gorm:"not null;unique;" json:"-" bson:"-"`

	// School for Class Twelve
	SchoolForClassTwelve string `gorm:"type:varchar(255)" json:"schoolForClassTwelve" binding:"required" bson:"schoolForClassTwelve"`

	// Class Twelve Percentage
	ClassTwelvePercentage float32 `gorm:"type:real" json:"classTwelvePercentage" binding:"gte=0,lte=100" bson:"classTwelvePercentage"`

	// Class Twelve Marksheet Document ID = Foreign key to Documents table.
	ClassTwelveMarksheetID uint32 `gorm:"not null;unique;" json:"-" bson:"-"`

	UpdatedAt time.Time `gorm:"autoUpdateTime"` // Automatically update timestamp

	// Relationships
	// Class Ten Marksheet Document Relationship
	ClassTenMarksheet StudentDocumentTable `gorm:"foreignKey:class_ten_marksheet_id;references:document_id;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`

	// Class Twelve Marksheet Document Relationship
	ClassTwelveMarksheet StudentDocumentTable `gorm:"foreignKey:class_twelve_marksheet_id;references:document_id;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
}

// TableName overrides the default table name
func (StudentAcademicDetailsTable) TableName() string {
	return "student_schema.student_academic_details_table"
}



================================================
File: internal/domain/student/student/student_certification_and_academic_details_table.go
================================================
// The certification and academic achievements store for students.
// Uses StudentDocumentTable for storing documents related to certifications.
// The DocumentID is a foreign key referencing the StudentDocumentTable table.
package student

import (
	"time"
)

type StudentCertificationDetailsTable struct {
	// ID = Primary Key (unique identifier for each student).
	// To be used internally only. Not to be sent in responses.
	ID uint32 `gorm:"primaryKey;autoIncrement" json:"-" bson:"-"`

	// CertificationName = Name of the certification earned by the student.
	CertificationName string `gorm:"type:varchar(255);not null" json:"certificationName" bson:"certificationName" binding:"required"`

	// IssuingAuthority = Name of the authority or organization that issued the certification.
	IssuingAuthority string `gorm:"type:varchar(255);not null" json:"issuingAuthority" bson:"issuingAuthority" binding:"required"`

	// IssuingDate = Date when the certification was issued. Defaults to the 30th of the month.
	IssuingDate string `gorm:"not null;" json:"issuingDate" bson:"issuingDate" binding:"required"`

	// DocumentID = Foreign key referencing the Documents table for storing certification-related documents.
	DocumentID uint32 `gorm:"not null;unique;" json:"-" bson:"-"`

	UpdatedAt time.Time `gorm:"autoUpdateTime"` // Automatically update timestamp

}

// TableName overrides the default table name
func (StudentCertificationDetailsTable) TableName() string {
	return "student_schema.student_certification_and_achievements_details_table"
}



================================================
File: internal/domain/student/student/student_certification_lookup.go
================================================
package student

type StudentCertificationLookup struct {
	EnrollmentNo                  string `gorm:"type:varchar(12);size:12;not null" json:"enrollmentNo"`
	StudentCertificationDetailsID uint32 `gorm:"primaryKey;not null" json:"certificationDetailsID"`

	// References to the certification details
	CertificationsAndAchievementsDetails StudentCertificationDetailsTable `gorm:"foreignKey:StudentCertificationDetailsID;references:ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (StudentCertificationLookup) TableName() string {
	return "student_schema.student_certification_lookup_table"
}



================================================
File: internal/domain/student/student/student_documents_table.go
================================================
// Description: This file includes the model for the student_documents_table table in the
// student_schema database.
// The central store for all the documents related to a student.
// Completely Independent of other tables.
// Referenced in other tables as a foreign key.
package student

import "time"

type StudentDocumentTable struct {
	DocumentID   uint32    `gorm:"primaryKey;not null;autoIncrement" json:"-" bson:"-"`
	StoredIn     string    `gorm:"varchar(255);size:255;not null" json:"-" bson:"-"`
	CreatedAt    time.Time `gorm:"type:timestamp with time zone;default:current_timestamp" json:"createdAt" bson:"createdAt"`
	UpdatedAt    time.Time `gorm:"type:timestamp with time zone;default:current_timestamp" json:"updatedAt" bson:"updatedAt"`
	DocumentType string    `gorm:"varchar(255);size:255" json:"documentType" bson:"documentType"`
	URL          string    `gorm:"varchar(255);size:255" json:"documentURL" bson:"documentURL"`

	// Relationships
	// Foreign key relationship with Documents table
	CertificationDocument StudentCertificationDetailsTable `gorm:"foreignKey:DocumentID;references:DocumentID;constraint:OnUpdate:CASCADE,OnDelete:RESTRICT;"`
}

// TableName overrides the default table name
func (StudentDocumentTable) TableName() string {
	return "student_schema.student_documents_table"
}



================================================
File: internal/domain/student/student/student_family_details_table.go
================================================
// This is an independent table that stores the family details of the student.
// Referenced by the `EnrollmentMasterLookupTable` table.
package student

import (
	"time"
)

type StudentFamilyDetailsTable struct {
	// ID = Primary Key (unique identifier for each student).
	// To be used internally only. Not to be sent in responses.
	ID uint32 `gorm:"primaryKey;autoIncrement" json:"-" bson:"-"`

	// Father's details
	FatherName          string `gorm:"type:varchar(100);not null" json:"fatherName" bson:"fatherName" binding:"required"`
	FatherQualification string `gorm:"type:varchar(100);not null" json:"fatherQualification" bson:"fatherQualification" binding:"required"`
	FatherProfession    string `gorm:"type:varchar(100);not null" json:"fatherProfession" bson:"fatherProfession" binding:"required"`

	// Mother's details
	MotherName          string `gorm:"type:varchar(100);not null" json:"motherName" bson:"motherName" binding:"required"`
	MotherQualification string `gorm:"type:varchar(100);not null" json:"motherQualification" bson:"motherQualification" binding:"required"`
	MotherProfession    string `gorm:"type:varchar(100);not null" json:"motherProfession" bson:"motherProfession" binding:"required"`

	// Number of siblings in the family
	NoOfSiblings int `gorm:"type:int;not null;" json:"noOfSiblings" bson:"noOfSiblings" binding:"required"`

	// Total family income in INR
	TotalFamilyIncome int `gorm:"type:int;not null;" json:"totalFamilyIncome" bson:"totalFamilyIncome" binding:"required"`

	// Timestamps for record updates
	UpdatedAt time.Time `gorm:"autoUpdateTime"` // Automatically update timestamp

}

// TableName overrides the default table name
func (StudentFamilyDetailsTable) TableName() string {
	return "student_schema.student_family_details_table"
}



================================================
File: internal/domain/student/student/student_log_in_details_table.go
================================================
// This stores the log in details of the student
// This is an independent table
// Referenced in the EnrollmentMasterLookupTable.
package student

type StudentLogInDetailsTable struct {
	ID       uint32 `gorm:"primaryKey" json:"-" bson:"-"` // The primary Key for this table
	Email    string `gorm:"type:varchar(255);unique;not null" json:"email"  bson:"email" validate:"required,email"`
	Password string `gorm:"type:varchar(255);not null" json:"password"  bson:"password" validate:"required"`
	Phone    string `gorm:"type:varchar(15);not null" json:"phone"  bson:"phone" validate:"required,phone"`
}

func (StudentLogInDetailsTable) TableName() string {
	return "student_schema.student_login_details_table"
}



================================================
File: internal/domain/student/student/student_practice_session_lookup_table.go
================================================
package student

type StudentPracticeSessionLookupTable struct {
	EnrollmentNo      string `gorm:"type:varchar(12);size:12;not null" json:"enrollmentNo"`                                                               // FK to student
	PracticeSessionID uint32 `gorm:"not null;primaryKey" json:"practiceSessionID"`                                                                        // FK to practice session
	Status            string `gorm:"type:varchar(9);size:9;not null;default:'Active';check:status IN ('Submitted', 'Active', 'Force End')" json:"status"` // Status of the practice session

	// Foreign key relationships
	PracticeSessionRecord StudentPracticeSessionRecordTable `gorm:"foreignKey:PracticeSessionID;references:PracticeSessionID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE"`
}

func (StudentPracticeSessionLookupTable) TableName() string {
	return "student_schema.student_practice_session_lookup_table"
}



================================================
File: internal/domain/student/student/student_practice_sessions_record_table.go
================================================
// This is an independent table that stores the practice session records of the students.

package student

import (
	"time"
)

type StudentPracticeSessionRecordTable struct {
	// PracticeSessionID = Unique identifier for each practice session
	PracticeSessionID uint32 `gorm:"primaryKey;not null" json:"sessionId" bson:"sessionId"`

	// DomainID = Category of the questions (e.g., Programming, Mathematics)
	DomainID uint32 `gorm:"not null" json:"domainID" bson:"domainID" binding:"required"`

	// SubDomainID = Sub-category of the questions (e.g., Data Structures, Algebra)
	SubDomainID uint32 `gorm:"not null" json:"subCategoryID" bson:"subCategoryID" binding:"required"`

	// DifficultyLevelID = DifficultyLevelID level of the session (e.g., Easy, Medium, Hard)
	DifficultyLevelID uint32 `gorm:"not null" json:"difficultyID" bson:"difficultyID" binding:"required"`

	// QuestionsAttempted = Number of questions attempted during the session
	QuestionsAttempted int `gorm:"not null" json:"questionsAttempted" bson:"questionsAttempted" binding:"required"`

	// QuestionsCorrect = Number of questions answered correctly
	QuestionsCorrect int `gorm:"not null" json:"questionsCorrect" bson:"questionsCorrect" binding:"required"`

	// ScoreEarned = Total score earned in the session
	ScoreEarned float64 `gorm:"not null" json:"scoreEarned" bson:"scoreEarned" binding:"required"`

	// StartTime = The time when the session started
	StartTime time.Time `gorm:"type:timestamp with time zone;not null" json:"startTime" bson:"startTime" binding:"required"`

	// EndTime = The time when the session ended
	EndTime time.Time `gorm:"type:timestamp with time zone;not null" json:"endTime" bson:"endTime" binding:"required"`

	// Feedbacks = Optional field for any feedback related to the session
	Feedbacks string `gorm:"type:varchar(255);default:''" json:"feedbacks" bson:"feedbacks"`
}

// TableName returns the name of the table in the database
func (StudentPracticeSessionRecordTable) TableName() string {
	return "student_schema.student_practice_session_records"
}



================================================
File: internal/domain/student/student/student_profile_details.go
================================================
// The basic profile details for the students.
// Uses document IDs from the StudentDocumentTable table for Photograph and Resume.
// Depends of the StudentDocumentTable table.
package student

import (
	"time"
)

type StudentProfileDetailsTable struct {
	// ID = Primary Key (unique identifier for each student).
	// To be used internally only. Not to be sent in responses.
	ID uint32 `gorm:"primaryKey;autoIncrement;unique" json:"-" bson:"-"`

	// UserRole = Privelage check parameter, defaults to 'STU' (Student)
	// To be used internally only. Not to be sent in responses.
	UserRole string `gorm:"type:varchar(3);size:3;not null;default:'STU';check:user_role IN ('STU','VOL','COR','ADM');" bson:"-" json:"-"`

	// Full name of the student
	Name string `gorm:"type:varchar(100);not null;size:100" json:"name" bson:"name" binding:"required"`

	// Gender: 'M' (Male), 'F' (Female), 'O' (Other)
	Gender string `gorm:"type:varchar(1);not null;size:1;check:gender IN ('M','F','O')" json:"gender" bson:"gender" binding:"required,oneof=M F O"`

	// Category: 'GEN', 'EWS', 'OBC', 'SC', or 'ST'
	// Extend if needed.
	Category string `gorm:"type:varchar(3);not null;size:3;check:category IN ('GEN','EWS','OBC','SC','ST')" json:"category" bson:"category" binding:"required,oneof=GEN EWS OBC SC ST"`

	// Foreign Key: References `DocumentID` in the `Documents` table for Photograph
	// To be used internally only. Not to be sent in responses.
	PhotographID uint32 `gorm:"not null;unique" json:"-" bson:"-" binding:"required"`

	// Foreign Key: References `DocumentID` in the `Documents` table for Resume
	// To be used internally only. Not to be sent in responses.
	ResumeID uint32 `gorm:"not null;unique" json:"-" bson:"-" binding:"required"`

	CreatedAt time.Time `gorm:"autoCreateTime"` // Automatically set timestamp
	UpdatedAt time.Time `gorm:"autoUpdateTime"` // Automatically update timestamp

	// Foreign key relations
	// Relationship to Documents table for Photograph
	Photograph StudentDocumentTable `gorm:"foreignKey:photograph_id;references:document_id;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
	// Relationship to Documents table for Resume
	Resume StudentDocumentTable `gorm:"foreignKey:resume_id;references:document_id;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
}

func (StudentProfileDetailsTable) TableName() string {
	return "student_schema.student_profile_details_table"
}



================================================
File: internal/domain/student/student/student_scholarship_details_table.go
================================================
// This is an independent table.
// Referenced in the EnrollmentDetailsTable.
package student

import (
	"time"
)

type StudentScholarshipDetailsTable struct {
	// ID = Primary Key (unique identifier for the scholarship record)
	ID uint32 `gorm:"primaryKey;autoIncrement" json:"-" bson:"-"`

	// Name of the scholarship received
	ScholarshipName string `gorm:"type:varchar(100);not null" json:"scholarshipName" bson:"scholarshipName" binding:"required"`

	// Organization or authority providing the scholarship
	ProvidedBy string `gorm:"type:varchar(100);not null" json:"providedBy" bson:"providedBy" binding:"required"`

	// Amount received for the scholarship
	AmountReceived int `gorm:"type:int;not null;" json:"amountReceived" bson:"amountReceived" binding:"required"`

	// Timestamps for record updates
	UpdatedAt time.Time `gorm:"autoUpdateTime"` // Automatically update timestamp
}

// TableName overrides the default table name
func (StudentScholarshipDetailsTable) TableName() string {
	return "student_schema.student_scholarship_details_table"
}



================================================
File: internal/eventbus/events/quiz_events.go
================================================



================================================
File: internal/eventbus/events/student_events.go
================================================



================================================
File: internal/eventbus/publisher/kafka_publisher.go
================================================



================================================
File: internal/eventbus/subscriber/kafka_subscriber.go
================================================



================================================
File: internal/infrastructure/auth/api_key_manager.go
================================================



================================================
File: internal/infrastructure/auth/jwt_provider.go
================================================



================================================
File: internal/infrastructure/auth/oauth_client.go
================================================



================================================
File: internal/infrastructure/cache/local_cache.go
================================================



================================================
File: internal/infrastructure/cache/redis_cache.go
================================================



================================================
File: internal/infrastructure/database/mongodb/connection.go
================================================



================================================
File: internal/infrastructure/database/postgres/connection.go
================================================
// internal/infrastructure/database/postgres/connection.go
package postgres

import (
	"context"
	"fmt"
	"server/internal/config"

	"github.com/jackc/pgx/v5/pgxpool"
)

// NewConnection creates a PostgreSQL connection pool using pgx
func NewConnection(cfg config.DatabaseConfig) (*pgxpool.Pool, error) {
	connStr := fmt.Sprintf(
		"postgres://%s:%s@%s:%s/%s?sslmode=%s",
		cfg.UserName,
		cfg.Password,
		cfg.Host,
		cfg.Port,
		cfg.DatabaseName,
		cfg.SSLMode,
	)

	// Create a connection pool
	config, err := pgxpool.ParseConfig(connStr)
	if err != nil {
		return nil, fmt.Errorf("failed to parse connection string: %w", err)
	}

	// Set connection pool parameters
	config.MaxConns = 10 // Adjust based on your needs
	config.MinConns = 2  // Keep a minimum of connections open

	// Create the pool
	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return nil, fmt.Errorf("failed to create connection pool: %w", err)
	}

	// Verify connection
	if err := pool.Ping(context.Background()); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	return pool, nil
}


================================================
File: internal/infrastructure/database/postgres/repositories/platform_profile_repo.go
================================================
// 2. TODO: Update the Soft and Hard Delete implementations to include `shifting
// deleted profiles to different recovery table` which is cleared by workers periodically
// and implement Restore Profile Function.
// 3. TODO: Update the schemas and table locations for tables not to be in public schema like profile_preferences, password_reset_tokens, recovery table, etc.
// 4. TODO: Update to include logging in all the functions.
// 5. TODO: Update if ProfilePreference model is changed to include other notifications.
//

// Soft Delete Profile archives the profile to deleted_profiles and removes it from platform_profiles
// The deleted_profiles table has deleted_at timestamp to track when the profile was deleted

package repositories

import (
	"context"
	"errors"
	"fmt"
	"server/internal/domain/platform_profile"
	"server/pkg/logger"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

var (
	ErrProfileNotFound       = errors.New("profile not found")
	ErrUsernameAlreadyExists = errors.New("username already exists")
	ErrEmailAlreadyExists    = errors.New("email already exists")
	ErrResetTokenNotFound    = errors.New("reset token not found")
	ErrResetTokenExpired     = errors.New("reset token expired")
	ErrResetTokenUsed        = errors.New("reset token already used")
	ErrRoleNotFound          = errors.New("role not found")
	ErrRoleNotAssigned       = errors.New("role not assigned or already removed")
)

// PostgresProfileRepository implements the platform_profile.Repository interface
type PostgresProfileRepository struct {
	pool   *pgxpool.Pool
	logger *logger.Logger // Add the logger
}

// NewPostgresProfileRepository creates a new PostgreSQL-backed profile repository
func NewPostgresProfileRepository(pool *pgxpool.Pool, logger *logger.Logger) platform_profile.Repository {
	return &PostgresProfileRepository{
		pool:   pool,
		logger: logger,
	}
}

// UsernameExists checks if a platform profile with the same username exists in the database
func (r *PostgresProfileRepository) UsernameExists(ctx context.Context, username string) (bool, error) {
	r.logger.Debug("Checking if username exists", "username", username)

	query := "SELECT EXISTS(SELECT 1 FROM platform_profiles WHERE username = $1)"
	var exists bool
	err := r.pool.QueryRow(ctx, query, username).Scan(&exists)
	if err != nil {
		r.logger.Error("Failed to check username existence", "username", username, "error", err)
		return false, fmt.Errorf("failed to check username existence: %w", err)
	}

	if exists {
		r.logger.Info("Username exists", "username", username)
	} else {
		r.logger.Debug("Username does not exist", "username", username)
	}
	return exists, nil
}

// EmailExists checks if a profile with the given email already exists
func (r *PostgresProfileRepository) EmailExists(ctx context.Context, email string) (bool, error) {
	r.logger.Debug("Checking if email exists", "email", email)

	query := "SELECT EXISTS(SELECT 1 FROM platform_profiles WHERE email = $1)"
	var exists bool
	err := r.pool.QueryRow(ctx, query, email).Scan(&exists)
	if err != nil {
		r.logger.Error("Failed to check email existence", "email", email, "error", err)
		return false, fmt.Errorf("failed to check email existence: %w", err)
	}

	if exists {
		r.logger.Info("Email exists", "email", email)
	} else {
		r.logger.Debug("Email does not exist", "email", email)
	}
	return exists, nil
}

// CreateProfile stores a new platform profile in the database
func (r *PostgresProfileRepository) CreateProfile(ctx context.Context, profile *platform_profile.PlatformProfile) error {

	r.logger.Debug(
		"Creating new profile",
		"username", profile.Username,
		"email", profile.Email,
	)

	query := `
	INSERT INTO platform_profiles (
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at		
	) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
	) RETURNING id`

	// Execute query
	var returnedID uuid.UUID
	err := r.pool.QueryRow(
		ctx,
		query,
		profile.ID,
		profile.Username,
		profile.Email,
		profile.PasswordHash,
		profile.Status,
		profile.VerifiedAt,
		profile.LastLoginAt,
		profile.FailedLoginAttempts,
		profile.CreatedAt,
		profile.UpdatedByUserAt,
		profile.UpdatedBySystemAt,
	).Scan(&returnedID)

	if err != nil {
		// Check for unique constraint violations
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			switch pgErr.ConstraintName {
			case "platform_profiles_username_key":
				r.logger.Warn("Username already exists",
					"username", profile.Username)
				return ErrUsernameAlreadyExists
			case "platform_profiles_email_key":
				r.logger.Warn("Email already exists",
					"email", profile.Email)
				return ErrEmailAlreadyExists
			}
		}
		r.logger.Error("Failed to create profile",
			"username", profile.Username,
			"error", err)
		return fmt.Errorf("failed to create profile: %w", err)
	}

	r.logger.Info(
		"Profile created successfully",
		"profileID", returnedID,
		"username", profile.Username,
	)

	profile.ID = returnedID
	return nil
}

// GetProfileByID retrieves a profile by its ID
func (r *PostgresProfileRepository) GetProfileByID(ctx context.Context, id uuid.UUID) (*platform_profile.PlatformProfile, error) {

	query := `
	SELECT 
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at
	FROM platform_profiles 
	WHERE id = $1`

	profile := &platform_profile.PlatformProfile{}
	err := r.pool.QueryRow(ctx, query, id).Scan(
		&profile.ID,
		&profile.Username,
		&profile.Email,
		&profile.PasswordHash,
		&profile.Status,
		&profile.VerifiedAt,
		&profile.LastLoginAt,
		&profile.FailedLoginAttempts,
		&profile.CreatedAt,
		&profile.UpdatedByUserAt,
		&profile.UpdatedBySystemAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrProfileNotFound
		}
		return nil, fmt.Errorf("failed to get profile by ID: %w", err)
	}

	return profile, nil
}

// GetProfileByEmail retrieves a profile by its email
func (r *PostgresProfileRepository) GetProfileByEmail(ctx context.Context, email string) (*platform_profile.PlatformProfile, error) {

	query := `
	SELECT 
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at
	FROM platform_profiles 
	WHERE email = $1`

	profile := &platform_profile.PlatformProfile{}
	err := r.pool.QueryRow(ctx, query, email).Scan(
		&profile.ID,
		&profile.Username,
		&profile.Email,
		&profile.PasswordHash,
		&profile.Status,
		&profile.VerifiedAt,
		&profile.LastLoginAt,
		&profile.FailedLoginAttempts,
		&profile.CreatedAt,
		&profile.UpdatedByUserAt,
		&profile.UpdatedBySystemAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrProfileNotFound
		}
		return nil, fmt.Errorf("failed to get profile by email: %w", err)
	}

	return profile, nil
}

// GetProfileByUsername retrieves a profile by its username
func (r *PostgresProfileRepository) GetProfileByUsername(ctx context.Context, username string) (*platform_profile.PlatformProfile, error) {

	query := `
	SELECT 
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at
	FROM platform_profiles 
	WHERE username = $1`

	profile := &platform_profile.PlatformProfile{}
	err := r.pool.QueryRow(ctx, query, username).Scan(
		&profile.ID,
		&profile.Username,
		&profile.Email,
		&profile.PasswordHash,
		&profile.Status,
		&profile.VerifiedAt,
		&profile.LastLoginAt,
		&profile.FailedLoginAttempts,
		&profile.CreatedAt,
		&profile.UpdatedByUserAt,
		&profile.UpdatedBySystemAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, ErrProfileNotFound
		}
		return nil, fmt.Errorf("failed to get profile by username: %w", err)
	}

	return profile, nil
}

// UpdateProfile updates an existing platform profile
func (r *PostgresProfileRepository) UpdateProfile(ctx context.Context, profile *platform_profile.PlatformProfile) error {
	r.logger.Debug(
		"Updating profile",
		"id", profile.ID,
		"username", profile.Username,
		"email", profile.Email,
	)

	query := `
	   UPDATE platform_profiles SET
			username = $1,
			email = $2,			
			updated_by_user_at = $3,
			updated_by_system_at = $4
	   WHERE id = $5`

	commandTag, err := r.pool.Exec(
		ctx,
		query,
		profile.Username,
		profile.Email,
		profile.UpdatedByUserAt,
		profile.UpdatedBySystemAt,
		profile.ID,
	)

	if err != nil {
		// Check for unique constraint violations
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			switch pgErr.ConstraintName {
			case "platform_profiles_username_key":
				r.logger.Warn("Username already exists", "username", profile.Username)
				return ErrUsernameAlreadyExists
			case "platform_profiles_email_key":
				r.logger.Warn("Email already exists", "email", profile.Email)
				return ErrEmailAlreadyExists
			}
		}
		r.logger.Error("Failed to update profile", "id", profile.ID, "error", err)
		return fmt.Errorf("failed to update profile: %w", err)
	}

	// Check if no rows were affected
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found for update", "id", profile.ID)
		return ErrProfileNotFound
	}

	r.logger.Info("Profile updated successfully", "id", profile.ID)
	return nil
}

// TODO: 2, 3

// SoftDeleteProfile archives the profile to deleted_profiles and removes it from platform_profiles
func (r *PostgresProfileRepository) SoftDeleteProfile(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Starting profile soft delete process", "id", id)

	// Begin a transaction to ensure atomicity
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		r.logger.Error(
			"Failed to start transaction for soft delete",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to start transaction for soft delete: %w", err)
	}
	defer tx.Rollback(ctx)

	// Archive the profile to the deleted_profiles table
	archiveQuery := `
	INSERT INTO profile_schema.deleted_profiles (
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at, deleted_at
	)
	SELECT 
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at, NOW()
	FROM platform_profiles
	WHERE id = $1
	`

	commandTag, err := tx.Exec(ctx, archiveQuery, id)
	if err != nil {
		r.logger.Error(
			"Failed to archive profile before soft delete",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to archive profile before soft delete: %w", err)
	}

	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found for soft delete", "id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Profile archived successfully", "id", id)

	// Permanently remove the profile from platform_profiles
	deleteQuery := `
	DELETE FROM platform_profiles WHERE id = $1
	`

	commandTag, err = tx.Exec(ctx, deleteQuery, id)
	if err != nil {
		r.logger.Error("Failed to delete profile after archiving", "id", id, "error", err)
		return fmt.Errorf("failed to delete profile after archiving: %w", err)
	}

	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile already deleted or not found", "id", id)
		return ErrProfileNotFound
	}

	// Commit the transaction after successful archiving and deletion
	if err = tx.Commit(ctx); err != nil {
		r.logger.Error("Failed to commit transaction for soft delete", "id", id, "error", err)
		return fmt.Errorf("failed to commit transaction for soft delete: %w", err)
	}

	r.logger.Info("Profile archived and removed from platform_profiles successfully", "id", id)
	return nil
}

// VerifyProfile marks a profile as verified by setting VerifiedAt timestamp
func (r *PostgresProfileRepository) VerifyProfile(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Starting profile verification process", "id", id)

	query := `
	UPDATE platform_profiles SET
		status = 'activated',
		verified_at = $1,
		updated_by_user_at = $1,
		updated_by_system_at = $1
	WHERE id = $2
	`

	now := time.Now()

	// Log query execution
	r.logger.Debug("Executing profile verification query", "id", id, "query", query)

	// Execute query
	commandTag, err := r.pool.Exec(ctx, query, now, id)
	if err != nil {
		r.logger.Error(
			"Failed to verify profile",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to verify profile: %w", err)
	}

	// Check if the profile was found and updated
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found or already verified", "id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Profile verified successfully", "id", id)
	return nil
}

// UpdateStatus updates the status of a profile
func (r *PostgresProfileRepository) UpdateStatus(ctx context.Context, id uuid.UUID, status platform_profile.Status) error {
	r.logger.Debug("Updating profile status", "id", id, "status", status)

	query := `
	UPDATE platform_profiles SET
		status = $1,
		updated_by_user_at = $2,
		updated_by_system_at = $2
	WHERE id = $3`

	// Execute the update query
	commandTag, err := r.pool.Exec(ctx, query, status, time.Now(), id)
	if err != nil {
		r.logger.Error("Failed to update profile status", "id", id, "status", status, "error", err)
		return fmt.Errorf("failed to update profile status: %w", err)
	}

	// Check if no rows were affected (i.e., profile not found)
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found while updating status", "id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Profile status updated successfully", "id", id, "status", status)
	return nil
}

// CreatePasswordResetToken stores a new password reset token
func (r *PostgresProfileRepository) CreatePasswordResetToken(ctx context.Context, resetToken *platform_profile.PasswordResetToken) error {
	r.logger.Debug(
		"Starting to create password reset token",
		"profile_id", resetToken.ProfileID,
	)

	query := `
	INSERT INTO profile_schema.password_reset_tokens (
		profile_id, token, expires_at, is_used, created_at
	) VALUES (
		$1, $2, $3, $4, $5
	)`

	// Execute the insert query
	_, err := r.pool.Exec(
		ctx,
		query,
		resetToken.ProfileID,
		resetToken.Token,
		resetToken.ExpiresAt,
		resetToken.IsUsed,
		resetToken.CreatedAt,
	)

	if err != nil {
		r.logger.Error(
			"Failed to create password reset token",
			"profile_id", resetToken.ProfileID,
			"error", err,
		)
		return fmt.Errorf("failed to create password reset token: %w", err)
	}

	r.logger.Info(
		"Password reset token created successfully",
		"profile_id", resetToken.ProfileID,
		"expires_at", resetToken.ExpiresAt,
	)
	return nil
}

// GetPasswordResetToken retrieves a password reset token
func (r *PostgresProfileRepository) GetPasswordResetToken(ctx context.Context, token string) (*platform_profile.PasswordResetToken, error) {
	r.logger.Debug("Fetching password reset token", "token", token)

	query := `
	SELECT 
		profile_id, token, expires_at, is_used, created_at
	FROM profile_schema.password_reset_tokens
	WHERE token = $1`

	resetToken := &platform_profile.PasswordResetToken{}
	err := r.pool.QueryRow(ctx, query, token).Scan(
		&resetToken.ProfileID,
		&resetToken.Token,
		&resetToken.ExpiresAt,
		&resetToken.IsUsed,
		&resetToken.CreatedAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			r.logger.Warn("Password reset token not found", "token", token)
			return nil, ErrResetTokenNotFound
		}
		r.logger.Error("Failed to fetch password reset token", "token", token, "error", err)
		return nil, fmt.Errorf("failed to get password reset token: %w", err)
	}

	r.logger.Info("Password reset token fetched successfully", "token", token, "profile_id", resetToken.ProfileID)
	return resetToken, nil
}

// MarkPasswordResetTokenUsed marks a token as used
func (r *PostgresProfileRepository) MarkPasswordResetTokenUsed(ctx context.Context, token string) error {
	r.logger.Debug("Marking password reset token as used", "token", token)

	query := `
	UPDATE profile_schema.password_reset_tokens SET
		is_used = true,
		updated_at = NOW()
	WHERE token = $1 AND is_used = false`

	commandTag, err := r.pool.Exec(ctx, query, token)
	if err != nil {
		r.logger.Error("Failed to mark password reset token as used", "token", token, "error", err)
		return fmt.Errorf("failed to mark password reset token as used: %w", err)
	}

	// Check if any rows were affected
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Password reset token not found or already used", "token", token)
		return ErrResetTokenNotFound
	}

	r.logger.Info("Password reset token marked as used successfully", "token", token)
	return nil
}

// UpdatePassword updates a profile's password hash
func (r *PostgresProfileRepository) UpdatePassword(ctx context.Context, id uuid.UUID, passwordHash string) error {
	r.logger.Debug("Starting password update process", "id", id)

	query := `
	UPDATE platform_profiles SET
		password_hash = $1,
		updated_by_user_at = $2,
		updated_by_system_at = $2
	WHERE id = $3
	`

	now := time.Now()

	// Log query execution
	r.logger.Debug("Executing password update query", "id", id, "query", query)

	// Execute query
	commandTag, err := r.pool.Exec(ctx, query, passwordHash, now, id)
	if err != nil {
		r.logger.Error(
			"Failed to update password",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to update password: %w", err)
	}

	// Check if the profile was found and updated
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found for password update", "id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Password updated successfully", "id", id)
	return nil
}

// DeleteOtherResetTokens deletes all other reset tokens for the profile except the used one
func (r *PostgresProfileRepository) DeleteOtherPasswordResetTokens(ctx context.Context, profileID uuid.UUID) error {
	r.logger.Debug("Starting to delete other password reset tokens", "profile_id", profileID)

	query := `
	DELETE FROM profile_schema.password_reset_tokens
	WHERE profile_id = $1
	`

	commandTag, err := r.pool.Exec(ctx, query, profileID)
	if err != nil {
		r.logger.Error(
			"Failed to delete other password reset tokens",
			"profile_id", profileID,
			"error", err,
		)
		return fmt.Errorf("failed to delete other password reset tokens: %w", err)
	}

	r.logger.Info(
		"Other password reset tokens deleted successfully",
		"profile_id", profileID,
		"tokens_deleted", commandTag.RowsAffected(),
	)

	return nil
}

// GetSoftDeletedProfileByEmail retrieves a soft-deleted profile by email
func (r *PostgresProfileRepository) GetSoftDeletedProfileByEmail(ctx context.Context, email string) (*platform_profile.PlatformProfile, error) {
	r.logger.Debug("Fetching soft-deleted profile by email", "email", email)

	query := `
	SELECT id, username, email, password_hash, status, verified_at, 
	       last_login_at, failed_login_attempts, created_at, updated_by_user_at,
	       updated_by_system_at
	FROM profile_schema.deleted_profiles
	WHERE email = $1
	`

	var profile platform_profile.PlatformProfile
	err := r.pool.QueryRow(ctx, query, email).Scan(
		&profile.ID,
		&profile.Username,
		&profile.Email,
		&profile.PasswordHash,
		&profile.Status,
		&profile.VerifiedAt,
		&profile.LastLoginAt,
		&profile.FailedLoginAttempts,
		&profile.CreatedAt,
		&profile.UpdatedByUserAt,
		&profile.UpdatedBySystemAt,
	)
	if err != nil {
		if err == pgx.ErrNoRows {
			r.logger.Warn("No soft-deleted profile found with the given email", "email", email)
			return nil, ErrProfileNotFound
		}
		r.logger.Error("Failed to fetch soft-deleted profile by email", "email", email, "error", err)
		return nil, ErrProfileNotFound
	}

	r.logger.Info("Soft-deleted profile fetched successfully by email", "email", email)
	return &profile, nil
}

// GetSoftDeletedProfileByUsername retrieves a soft-deleted profile by username
func (r *PostgresProfileRepository) GetSoftDeletedProfileByUsername(ctx context.Context, username string) (*platform_profile.PlatformProfile, error) {
	r.logger.Debug("Fetching soft-deleted profile by username", "username", username)

	query := `
	SELECT id, username, email, password_hash, status, verified_at, 
	       last_login_at, failed_login_attempts, created_at, updated_by_user_at,
	       updated_by_system_at
	FROM profile_schema.deleted_profiles
	WHERE username = $1
	`

	var profile platform_profile.PlatformProfile
	err := r.pool.QueryRow(ctx, query, username).Scan(
		&profile.ID,
		&profile.Username,
		&profile.Email,
		&profile.PasswordHash,
		&profile.Status,
		&profile.VerifiedAt,
		&profile.LastLoginAt,
		&profile.FailedLoginAttempts,
		&profile.CreatedAt,
		&profile.UpdatedByUserAt,
		&profile.UpdatedBySystemAt,
	)
	if err != nil {
		if err == pgx.ErrNoRows {
			r.logger.Warn("No soft-deleted profile found with the given username", "username", username)
			return nil, ErrProfileNotFound
		}
		r.logger.Error("Failed to fetch soft-deleted profile by username", "username", username, "error", err)
		return nil, ErrProfileNotFound
	}

	r.logger.Info("Soft-deleted profile fetched successfully by username", "username", username)
	return &profile, nil
}

// RestoreSoftDeletedProfile restores a soft-deleted profile by id
func (r *PostgresProfileRepository) RestoreSoftDeletedProfile(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Starting profile restoration process", "id", id)

	// Begin a transaction
	tx, err := r.pool.Begin(ctx)
	if err != nil {
		r.logger.Error(
			"Failed to start transaction for profile restoration",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to start transaction for profile restoration: %w", err)
	}
	defer tx.Rollback(ctx)

	// Restore profile from deleted_profiles to platform_profiles
	restoreQuery := `
	INSERT INTO platform_profiles (
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at
	)
	SELECT 
		id, username, email, password_hash, status, verified_at, 
		last_login_at, failed_login_attempts, created_at, updated_by_user_at,
		updated_by_system_at
	FROM profile_schema.deleted_profiles
	WHERE id = $1
	ON CONFLICT (id) DO NOTHING
	RETURNING id
	`

	var restoredID uuid.UUID
	err = tx.QueryRow(ctx, restoreQuery, id).Scan(&restoredID)
	if err != nil {
		if err == pgx.ErrNoRows {
			r.logger.Warn("No soft-deleted profile found for restoration", "id", id)
			return ErrProfileNotFound
		}
		r.logger.Error("Failed to restore profile from deleted_profiles", "id", id, "error", err)
		return fmt.Errorf("failed to restore profile: %w", err)
	}

	r.logger.Info("Profile restored successfully", "id", id, "restoredID", restoredID)

	// Delete the restored profile from deleted_profiles
	deleteQuery := `
	DELETE FROM profile_schema.deleted_profiles WHERE id = $1
	`

	commandTag, err := tx.Exec(ctx, deleteQuery, id)
	if err != nil {
		r.logger.Error(
			"Failed to delete restored profile from deleted_profiles",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to delete restored profile from deleted_profiles: %w", err)
	}

	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile was not found or already restored", "id", id)
		return ErrProfileNotFound
	}

	// Commit transaction after successful restoration and deletion
	if err = tx.Commit(ctx); err != nil {
		r.logger.Error(
			"Failed to commit transaction for profile restoration",
			"id", id,
			"error", err,
		)
		return fmt.Errorf("failed to commit transaction for profile restoration: %w", err)
	}

	r.logger.Info("Profile restoration completed successfully", "id", id)
	return nil
}

// HardDeleteProfile removes a profile from the deleted_profiles table in profile_schema
func (r *PostgresProfileRepository) HardDeleteProfile(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Starting hard delete process for profile", "id", id)

	// Delete query to remove the profile from deleted_profiles table
	query := `DELETE FROM profile_schema.deleted_profiles WHERE id = $1`

	commandTag, err := r.pool.Exec(ctx, query, id)
	if err != nil {
		r.logger.Error("Failed to delete profile from deleted_profiles", "id", id, "error", err)
		return fmt.Errorf("failed to delete profile from deleted_profiles: %w", err)
	}

	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found in deleted_profiles for hard delete", "id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Profile successfully deleted from deleted_profiles", "id", id)
	return nil
}

// AssignRoleToProfile assigns a role to a profile in the profile_roles table
func (r *PostgresProfileRepository) AssignRoleToProfile(ctx context.Context, profileID, roleID uuid.UUID) error {

	r.logger.Debug(
		"Starting to assign role to profile",
		"profile_id",
		profileID,
		"role_id",
		roleID,
	)

	query := `
	INSERT INTO profile_schema.profile_roles (
		profile_id, role_id, created_at
	) VALUES (
		$1, $2, $3
	) ON CONFLICT (profile_id, role_id) DO NOTHING
	`

	// Execute the query to assign the role
	_, err := r.pool.Exec(ctx, query, profileID, roleID, time.Now())
	if err != nil {
		r.logger.Error(
			"Failed to assign role to profile",
			"profile_id", profileID,
			"role_id", roleID,
			"error", err,
		)
		return fmt.Errorf("failed to assign role to profile: %w", err)
	}

	r.logger.Info("Role assigned to profile successfully", "profile_id", profileID, "role_id", roleID)
	return nil
}

// GetProfileRoles retrieves all roles assigned to a profile
func (r *PostgresProfileRepository) GetProfileRoles(ctx context.Context, profileID uuid.UUID) ([]uuid.UUID, error) {
	r.logger.Debug("Fetching roles assigned to profile", "profile_id", profileID)

	query := `
	SELECT role_id
	FROM profile_schema.profile_roles
	WHERE profile_id = $1`

	// Query to get roles
	rows, err := r.pool.Query(ctx, query, profileID)
	if err != nil {
		r.logger.Error("Failed to query profile roles", "profile_id", profileID, "error", err)
		return nil, fmt.Errorf("failed to get profile roles: %w", err)
	}
	defer rows.Close()

	var roleIDs []uuid.UUID

	// Iterate over the result set
	for rows.Next() {
		var roleID uuid.UUID
		if err := rows.Scan(&roleID); err != nil {
			r.logger.Error("Failed to scan role ID", "profile_id", profileID, "error", err)
			return nil, fmt.Errorf("failed to scan role ID: %w", err)
		}
		roleIDs = append(roleIDs, roleID)
	}

	// Check for errors after iteration
	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating over role rows", "profile_id", profileID, "error", err)
		return nil, fmt.Errorf("error iterating over role rows: %w", err)
	}

	// Log if no roles are found
	if len(roleIDs) == 0 {
		r.logger.Warn("No roles found for profile", "profile_id", profileID)
	}

	r.logger.Info("Roles retrieved successfully for profile", "profile_id", profileID, "role_count", len(roleIDs))
	return roleIDs, nil
}

// RemoveRoleFromProfile removes a role from a profile
func (r *PostgresProfileRepository) RemoveRoleFromProfile(ctx context.Context, profileID, roleID uuid.UUID) error {
	r.logger.Debug("Starting to remove role from profile", "profile_id", profileID, "role_id", roleID)

	query := `
	DELETE FROM profile_schema.profile_roles
	WHERE profile_id = $1 AND role_id = $2`

	// Execute the query to remove the role
	commandTag, err := r.pool.Exec(ctx, query, profileID, roleID)
	if err != nil {
		r.logger.Error(
			"Failed to remove role from profile",
			"profile_id", profileID,
			"role_id", roleID,
			"error", err,
		)
		return fmt.Errorf("failed to remove role from profile: %w", err)
	}

	// Check if any rows were affected
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn(
			"Role not found for profile or already removed",
			"profile_id", profileID,
			"role_id", roleID,
		)
		return ErrRoleNotAssigned
	}

	r.logger.Info("Role removed successfully from profile", "profile_id", profileID, "role_id", roleID)
	return nil
}

// TODO: 5
// SavePreferences saves profile preferences
func (r *PostgresProfileRepository) SavePreferences(ctx context.Context, prefs *platform_profile.ProfilePreference) error {

	r.logger.Debug(
		"Saving profile preferences",
		"profileID", prefs.ProfileID,
	)

	// Check if preference already exists
	existingPrefs, err := r.GetPreferences(ctx, prefs.ProfileID)

	if err != nil && !errors.Is(err, ErrProfileNotFound) {
		r.logger.Error(
			"Failed to check existing preferences",
			"profileID", prefs.ProfileID,
			"error", err,
		)
		return err
	}

	var query string
	if existingPrefs != nil {
		// Update existing preferences
		query = `
		UPDATE profile_schema.profile_preferences SET 
			notifications_email = $1, 			
			updated_at = $2 
		WHERE profile_id = $3`

		_, err = r.pool.Exec(
			ctx,
			query,
			prefs.NotificationsEmail,
			time.Now(),
			prefs.ProfileID,
		)
	} else {
		// Insert new preferences
		query = `
		INSERT INTO profile_schema.profile_preferences ( 
			id, profile_id, notifications_email, created_at, updated_at 
		) VALUES ( 
			$1, $2, $3, $4, $5
		)`

		now := time.Now()

		// Generate a new UUID if ID is not provided
		if prefs.ID == uuid.Nil {
			prefs.ID = uuid.New()
		}

		_, err = r.pool.Exec(
			ctx,
			query,
			prefs.ID,
			prefs.ProfileID,
			prefs.NotificationsEmail,
			now,
			now,
		)
	}

	if err != nil {
		r.logger.Error(
			"Failed to save profile preferences",
			"profileID", prefs.ProfileID,
			"error", err,
		)
		return fmt.Errorf("failed to save profile preferences: %w", err)
	}

	r.logger.Info(
		"Profile preferences saved successfully",
		"profileID", prefs.ProfileID,
	)

	return nil
}

// TODO: 5
// GetPreferences retrieves profile preferences
func (r *PostgresProfileRepository) GetPreferences(ctx context.Context, profileID uuid.UUID) (*platform_profile.ProfilePreference, error) {

	r.logger.Debug(
		"Getting profile preferences",
		"profileID", profileID,
	)

	query := `
	SELECT  
		id,
		profile_id, 
		notifications_email,
		created_at, 
		updated_at 
	FROM profile_schema.profile_preferences  
	WHERE profile_id = $1`

	prefs := &platform_profile.ProfilePreference{}
	err := r.pool.QueryRow(ctx, query, profileID).Scan(
		&prefs.ID,
		&prefs.ProfileID,
		&prefs.NotificationsEmail,
		&prefs.CreatedAt,
		&prefs.UpdatedAt,
	)

	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			r.logger.Debug(
				"Profile preferences not found",
				"profileID", profileID,
			)
			return nil, ErrProfileNotFound
		}
		r.logger.Error(
			"Failed to get profile preferences",
			"profileID", profileID,
			"error", err,
		)
		return nil, fmt.Errorf("failed to get profile preferences: %w", err)
	}

	r.logger.Debug(
		"Profile preferences retrieved successfully",
		"profileID", profileID,
	)

	return prefs, nil
}

// GetProfiles retrieves profiles with pagination and filtering
func (r *PostgresProfileRepository) GetProfiles(ctx context.Context, offset, limit int, filters map[string]interface{}) ([]*platform_profile.PlatformProfile, int, error) {
	r.logger.Debug("Fetching profiles with pagination and filters", "offset", offset, "limit", limit, "filters", filters)

	// Base queries for profiles and count
	baseQuery := `
	SELECT 
		id, username, email, password_hash, first_name, last_name, 
		display_name, status, created_at, updated_by_user_at, 
		last_login_at, failed_login_attempts, verified_at
	FROM profile_schema.platform_profiles`

	countQuery := `SELECT COUNT(*) FROM profile_schema.platform_profiles`

	// Build WHERE clause for filters
	whereClause := ""
	args := []interface{}{}
	paramIndex := 1

	if len(filters) > 0 {
		whereClause = " WHERE "
		conditions := []string{}

		for key, value := range filters {
			switch key {
			case "status":
				conditions = append(conditions, fmt.Sprintf("status = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "verified":
				conditions = append(conditions, fmt.Sprintf("verified_at IS NOT NULL AND verified_at <= $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "search":
				search := fmt.Sprintf("%%%s%%", value)
				conditions = append(conditions, fmt.Sprintf("(username ILIKE $%d OR email ILIKE $%d OR first_name ILIKE $%d OR last_name ILIKE $%d)",
					paramIndex, paramIndex+1, paramIndex+2, paramIndex+3))
				args = append(args, search, search, search, search)
				paramIndex += 4
			case "created_after":
				conditions = append(conditions, fmt.Sprintf("created_at > $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "created_before":
				conditions = append(conditions, fmt.Sprintf("created_at < $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			}
		}

		whereClause += strings.Join(conditions, " AND ")
	}

	// Build final queries
	dataQuery := baseQuery + whereClause + fmt.Sprintf(" ORDER BY created_at DESC LIMIT $%d OFFSET $%d", paramIndex, paramIndex+1)
	countQueryFinal := countQuery + whereClause

	// Add pagination parameters
	args = append(args, limit, offset)

	// Get total count of records
	var total int
	err := r.pool.QueryRow(ctx, countQueryFinal, args[:len(args)-2]...).Scan(&total)
	if err != nil {
		r.logger.Error("Failed to get profiles count", "error", err)
		return nil, 0, fmt.Errorf("failed to get profiles count: %w", err)
	}

	// Execute data query
	rows, err := r.pool.Query(ctx, dataQuery, args...)
	if err != nil {
		r.logger.Error("Failed to get profiles", "error", err)
		return nil, 0, fmt.Errorf("failed to get profiles: %w", err)
	}
	defer rows.Close()

	// Process query results
	profiles := []*platform_profile.PlatformProfile{}
	for rows.Next() {
		profile := &platform_profile.PlatformProfile{}
		err := rows.Scan(
			&profile.ID,
			&profile.Username,
			&profile.Email,
			&profile.PasswordHash,
			&profile.Status,
			&profile.VerifiedAt,
			&profile.LastLoginAt,
			&profile.FailedLoginAttempts,
			&profile.CreatedAt,
			&profile.UpdatedByUserAt,
			&profile.UpdatedBySystemAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan profile", "error", err)
			return nil, 0, fmt.Errorf("failed to scan profile: %w", err)
		}
		profiles = append(profiles, profile)
	}

	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating over profile rows", "error", err)
		return nil, 0, fmt.Errorf("error iterating over rows: %w", err)
	}

	r.logger.Info("Profiles fetched successfully", "total_profiles", len(profiles))
	return profiles, total, nil
}

// GetProfilesByRole retrieves profiles assigned to a specific role with pagination
func (r *PostgresProfileRepository) GetProfilesByRole(ctx context.Context, roleID uuid.UUID, page, pageSize int) ([]*platform_profile.PlatformProfile, int, error) {
	r.logger.Debug("Fetching profiles by role", "role_id", roleID, "page", page, "page_size", pageSize)

	// Calculate offset based on page and pageSize
	offset := (page - 1) * pageSize

	// Base query to get profiles by role
	baseQuery := `
	SELECT 
		p.id, p.username, p.email, p.password_hash, p.first_name, 
		p.last_name, p.display_name, p.status, p.created_at, 
		p.updated_by_user_at, p.last_login_at, p.failed_login_attempts, p.verified_at
	FROM profile_schema.platform_profiles AS p
	JOIN profile_schema.profile_roles AS pr ON p.id = pr.profile_id
	WHERE pr.role_id = $1
	ORDER BY p.created_at DESC
	LIMIT $2 OFFSET $3`

	// Query to count total profiles with the given role
	countQuery := `
	SELECT COUNT(*)
	FROM profile_schema.platform_profiles AS p
	JOIN profile_schema.profile_roles AS pr ON p.id = pr.profile_id
	WHERE pr.role_id = $1`

	// Get the total count of profiles with the given role
	var total int
	err := r.pool.QueryRow(ctx, countQuery, roleID).Scan(&total)
	if err != nil {
		r.logger.Error("Failed to get profile count by role", "role_id", roleID, "error", err)
		return nil, 0, fmt.Errorf("failed to get profile count by role: %w", err)
	}

	// Fetch profiles with the specified role
	rows, err := r.pool.Query(ctx, baseQuery, roleID, pageSize, offset)
	if err != nil {
		r.logger.Error("Failed to get profiles by role", "role_id", roleID, "error", err)
		return nil, 0, fmt.Errorf("failed to get profiles by role: %w", err)
	}
	defer rows.Close()

	// Process the query results
	profiles := []*platform_profile.PlatformProfile{}
	for rows.Next() {
		profile := &platform_profile.PlatformProfile{}
		err := rows.Scan(
			&profile.ID,
			&profile.Username,
			&profile.Email,
			&profile.PasswordHash,
			&profile.Status,
			&profile.VerifiedAt,
			&profile.LastLoginAt,
			&profile.FailedLoginAttempts,
			&profile.CreatedAt,
			&profile.UpdatedByUserAt,
			&profile.UpdatedBySystemAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan profile by role", "role_id", roleID, "error", err)
			return nil, 0, fmt.Errorf("failed to scan profile by role: %w", err)
		}
		profiles = append(profiles, profile)
	}

	// Check for iteration errors
	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating over profile rows by role", "role_id", roleID, "error", err)
		return nil, 0, fmt.Errorf("error iterating over profile rows by role: %w", err)
	}

	r.logger.Info("Profiles fetched successfully by role", "role_id", roleID, "total_profiles", len(profiles))
	return profiles, total, nil
}

// GetProfilesByPreferences retrieves profiles that match specific preferences with pagination
func (r *PostgresProfileRepository) GetProfilesByPreferences(ctx context.Context, preferences map[string]interface{}, page, pageSize int) ([]*platform_profile.PlatformProfile, int, error) {
	r.logger.Debug("Fetching profiles by preferences", "preferences", preferences, "page", page, "page_size", pageSize)

	// Calculate offset for pagination
	offset := (page - 1) * pageSize

	// Base query to get profiles matching preferences
	baseQuery := `
	SELECT 
		p.id, p.username, p.email, p.password_hash, p.first_name, p.last_name,
		p.display_name, p.status, p.created_at, p.updated_by_user_at, 
		p.last_login_at, p.failed_login_attempts, p.verified_at
	FROM profile_schema.platform_profiles p
	JOIN profile_schema.profile_preferences pref ON p.id = pref.profile_id`

	// Count query to get the total number of matching profiles
	countQuery := `
	SELECT COUNT(*)
	FROM profile_schema.platform_profiles p
	JOIN profile_schema.profile_preferences pref ON p.id = pref.profile_id`

	// Prepare WHERE clause for preferences
	whereClause := ""
	args := []interface{}{}
	paramIndex := 1

	if len(preferences) > 0 {
		whereClause = " WHERE "
		conditions := []string{}

		for key, value := range preferences {
			switch key {
			case "notifications_email":
				conditions = append(conditions, fmt.Sprintf("pref.notifications_email = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "notifications_push":
				conditions = append(conditions, fmt.Sprintf("pref.notifications_push = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "notifications_sms":
				conditions = append(conditions, fmt.Sprintf("pref.notifications_sms = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "language":
				conditions = append(conditions, fmt.Sprintf("pref.language ILIKE $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "dark_mode_on":
				conditions = append(conditions, fmt.Sprintf("pref.dark_mode_on = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "status":
				conditions = append(conditions, fmt.Sprintf("p.status = $%d", paramIndex))
				args = append(args, value)
				paramIndex++
			case "verified":
				notStr := ""
				if value.(bool) {
					notStr = "NOT"
				}
				conditions = append(conditions, fmt.Sprintf("p.verified_at IS %s NULL", notStr))
			case "search":
				search := fmt.Sprintf("%%%s%%", value)
				conditions = append(conditions, fmt.Sprintf("(p.username ILIKE $%d OR p.email ILIKE $%d OR p.first_name ILIKE $%d OR p.last_name ILIKE $%d)",
					paramIndex, paramIndex+1, paramIndex+2, paramIndex+3))
				args = append(args, search, search, search, search)
				paramIndex += 4
			}
		}

		whereClause += strings.Join(conditions, " AND ")
	}

	// Complete data and count queries
	dataQuery := baseQuery + whereClause + fmt.Sprintf(" ORDER BY p.created_at DESC LIMIT $%d OFFSET $%d", paramIndex, paramIndex+1)
	countQueryFinal := countQuery + whereClause

	// Add pagination parameters
	args = append(args, pageSize, offset)

	// Get total count of matching profiles
	var total int
	err := r.pool.QueryRow(ctx, countQueryFinal, args[:len(args)-2]...).Scan(&total)
	if err != nil {
		r.logger.Error("Failed to get profile count by preferences", "preferences", preferences, "error", err)
		return nil, 0, fmt.Errorf("failed to get profile count by preferences: %w", err)
	}

	// Execute query to fetch profiles
	rows, err := r.pool.Query(ctx, dataQuery, args...)
	if err != nil {
		r.logger.Error("Failed to get profiles by preferences", "preferences", preferences, "error", err)
		return nil, 0, fmt.Errorf("failed to get profiles by preferences: %w", err)
	}
	defer rows.Close()

	// Process query results
	profiles := []*platform_profile.PlatformProfile{}
	for rows.Next() {
		profile := &platform_profile.PlatformProfile{}
		err := rows.Scan(
			&profile.ID,
			&profile.Username,
			&profile.Email,
			&profile.PasswordHash,
			&profile.Status,
			&profile.VerifiedAt,
			&profile.LastLoginAt,
			&profile.FailedLoginAttempts,
			&profile.CreatedAt,
			&profile.UpdatedByUserAt,
			&profile.UpdatedBySystemAt,
		)
		if err != nil {
			r.logger.Error("Failed to scan profile by preferences", "preferences", preferences, "error", err)
			return nil, 0, fmt.Errorf("failed to scan profile by preferences: %w", err)
		}
		profiles = append(profiles, profile)
	}

	// Check for iteration errors
	if err := rows.Err(); err != nil {
		r.logger.Error("Error iterating over profile rows by preferences", "preferences", preferences, "error", err)
		return nil, 0, fmt.Errorf("error iterating over profile rows by preferences: %w", err)
	}

	r.logger.Info("Profiles fetched successfully by preferences", "total_profiles", len(profiles))
	return profiles, total, nil
}

// DeleteProfiles deletes multiple profiles either as a hard delete or a soft delete
func (r *PostgresProfileRepository) DeleteProfiles(ctx context.Context, profileIDs []uuid.UUID, hardDelete bool) error {
	r.logger.Debug("Starting profile deletion process", "hard_delete", hardDelete, "profile_ids", profileIDs)

	if len(profileIDs) == 0 {
		r.logger.Warn("No profile IDs provided for deletion")
		return nil
	}

	// Prepare query placeholders for IN clause
	placeholders := make([]string, len(profileIDs))
	args := make([]interface{}, len(profileIDs))
	for i, id := range profileIDs {
		placeholders[i] = fmt.Sprintf("$%d", i+1)
		args[i] = id
	}
	idList := strings.Join(placeholders, ", ")

	var query string
	var err error

	if hardDelete {
		// Hard delete: Permanently remove profiles and related records
		query = fmt.Sprintf(`
		DELETE FROM profile_schema.platform_profiles
		WHERE id IN (%s)`, idList)

		_, err = r.pool.Exec(ctx, query, args...)
		if err != nil {
			r.logger.Error("Failed to hard delete profiles", "error", err, "profile_ids", profileIDs)
			return fmt.Errorf("failed to hard delete profiles: %w", err)
		}
		r.logger.Info("Profiles permanently deleted successfully", "profile_ids", profileIDs)
	} else {
		// Soft delete: Mark profiles as deleted and store them in deleted_profiles
		tx, err := r.pool.Begin(ctx)
		if err != nil {
			r.logger.Error("Failed to start transaction for soft delete", "error", err)
			return fmt.Errorf("failed to start transaction for soft delete: %w", err)
		}
		defer func() {
			if err != nil {
				_ = tx.Rollback(ctx)
			}
		}()

		// Move profiles to deleted_profiles table before marking them as deleted
		moveQuery := fmt.Sprintf(`
		INSERT INTO profile_schema.deleted_profiles (
			id, username, email, password_hash, first_name, last_name, 
			display_name, status, created_at, updated_by_user_at, 
			last_login_at, failed_login_attempts, verified_at, 
			deleted_at
		)
		SELECT 
			id, username, email, password_hash, first_name, last_name, 
			display_name, status, created_at, updated_by_user_at, 
			last_login_at, failed_login_attempts, verified_at, 
			NOW()
		FROM profile_schema.platform_profiles
		WHERE id IN (%s)`, idList)

		_, err = tx.Exec(ctx, moveQuery, args...)
		if err != nil {
			r.logger.Error("Failed to move profiles to deleted_profiles for soft delete", "error", err, "profile_ids", profileIDs)
			return fmt.Errorf("failed to move profiles to deleted_profiles: %w", err)
		}

		// Commit the transaction
		err = tx.Commit(ctx)
		if err != nil {
			r.logger.Error("Failed to commit transaction for soft delete", "error", err)
			return fmt.Errorf("failed to commit transaction: %w", err)
		}
		r.logger.Info("Profiles soft deleted successfully and moved to deleted_profiles", "profile_ids", profileIDs)
	}

	return nil
}

// RecordLogin updates the last login timestamp and resets failed login attempts
func (r *PostgresProfileRepository) RecordLogin(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Recording login for profile", "profile_id", id)

	query := `
	UPDATE profile_schema.platform_profiles
	SET
		last_login_at = $1,
		updated_by_system_at = $1,
		failed_login_attempts = 0
	WHERE id = $2
	`

	now := time.Now()

	// Execute the query to update login information
	commandTag, err := r.pool.Exec(ctx, query, now, id)
	if err != nil {
		r.logger.Error("Failed to record login", "profile_id", id, "error", err)
		return fmt.Errorf("failed to record login: %w", err)
	}

	// Check if any rows were affected (handle profile not found case)
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found or already deleted", "profile_id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Login recorded successfully", "profile_id", id, "last_login_at", now)
	return nil
}

// IncrementFailedLoginAttempts increments the failed login attempts counter for a profile
func (r *PostgresProfileRepository) IncrementFailedLoginAttempts(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Incrementing failed login attempts", "profile_id", id)

	query := `
	UPDATE profile_schema.platform_profiles
	SET
		failed_login_attempts = failed_login_attempts + 1,
		updated_by_system_at = $1
	WHERE id = $2 `

	now := time.Now()

	// Execute the query to increment failed login attempts
	commandTag, err := r.pool.Exec(ctx, query, now, id)
	if err != nil {
		r.logger.Error("Failed to increment failed login attempts", "profile_id", id, "error", err)
		return fmt.Errorf("failed to increment failed login attempts: %w", err)
	}

	// Check if any rows were affected (profile not found or deleted)
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found or already deleted, failed attempts not incremented", "profile_id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Failed login attempts incremented successfully", "profile_id", id)
	return nil
}

// ResetFailedLoginAttempts resets the failed login attempts counter for a profile
func (r *PostgresProfileRepository) ResetFailedLoginAttempts(ctx context.Context, id uuid.UUID) error {
	r.logger.Debug("Resetting failed login attempts", "profile_id", id)

	query := `
	UPDATE profile_schema.platform_profiles
	SET
		failed_login_attempts = 0,
		updated_by_system_at = $1
	WHERE id = $2
	`

	now := time.Now()

	// Execute the query to reset failed login attempts
	commandTag, err := r.pool.Exec(ctx, query, now, id)
	if err != nil {
		r.logger.Error("Failed to reset failed login attempts", "profile_id", id, "error", err)
		return fmt.Errorf("failed to reset failed login attempts: %w", err)
	}

	// Check if any rows were affected (profile not found or deleted)
	if commandTag.RowsAffected() == 0 {
		r.logger.Warn("Profile not found or already deleted, failed attempts not reset", "profile_id", id)
		return ErrProfileNotFound
	}

	r.logger.Info("Failed login attempts reset successfully", "profile_id", id)
	return nil
}



================================================
File: internal/infrastructure/database/postgres/repositories/quiz_repo.go
================================================
package repositories



================================================
File: internal/infrastructure/database/postgres/repositories/student_repo.go
================================================
package repositories



================================================
File: internal/infrastructure/discovery/service_registry.go
================================================



================================================
File: internal/infrastructure/email/smtp_provider.go
================================================



================================================
File: internal/infrastructure/email/template_engine.go
================================================



================================================
File: internal/infrastructure/fallback/notification_fallback.go
================================================



================================================
File: internal/infrastructure/fallback/storage_fallback.go
================================================



================================================
File: internal/infrastructure/integration/canva/design_client.go
================================================



================================================
File: internal/infrastructure/integration/factory/ai_factory.go
================================================



================================================
File: internal/infrastructure/integration/factory/notification_factory.go
================================================



================================================
File: internal/infrastructure/integration/factory/storage_factory.go
================================================



================================================
File: internal/infrastructure/integration/google/auth.go
================================================



================================================
File: internal/infrastructure/integration/google/calendar.go
================================================



================================================
File: internal/infrastructure/integration/google/drive.go
================================================



================================================
File: internal/infrastructure/integration/huggingface/client.go
================================================



================================================
File: internal/infrastructure/integration/huggingface/model_manager.go
================================================



================================================
File: internal/infrastructure/integration/onesignal/notification_client.go
================================================



================================================
File: internal/infrastructure/integration/versioning/version_manager.go
================================================



================================================
File: internal/infrastructure/migration/service_switcher.go
================================================



================================================
File: internal/infrastructure/monitoring/integration_health.go
================================================



================================================
File: internal/infrastructure/monitoring/alerts/service_degradation.go
================================================



================================================
File: internal/infrastructure/offline/offline_queue.go
================================================



================================================
File: internal/infrastructure/quota/limit_tracker.go
================================================



================================================
File: internal/infrastructure/quota/throttling_service.go
================================================



================================================
File: internal/infrastructure/sdk/google_sdk_wrapper.go
================================================



================================================
File: internal/infrastructure/sdk/huggingface_sdk_wrapper.go
================================================



================================================
File: internal/infrastructure/storage/local_storage.go
================================================



================================================
File: internal/infrastructure/storage/s3_storage.go
================================================



================================================
File: internal/security/scanner/integration_scanner.go
================================================



================================================
File: internal/tenant/integration_config.go
================================================



================================================
File: internal/worker/analytics/report_worker.go
================================================



================================================
File: internal/worker/email/notification_worker.go
================================================



================================================
File: internal/worker/notification/push_worker.go
================================================



================================================
File: migrations/postgres/000001_create_students.down.sql
================================================
DROP TABLE IF EXISTS student_schema.student_leaderboard_records_table CASCADE;
DROP TABLE IF EXISTS student_schema.student_academic_details_table CASCADE;
DROP TABLE IF EXISTS student_schema.student_login_details_table CASCADE;


================================================
File: migrations/postgres/000001_create_students.up.sql
================================================
CREATE TABLE student_schema.student_leaderboard_records_table (
	LeaderboardRecordID SERIAL PRIMARY KEY,
	Rank INT NOT NULL,
	Score FLOAT NOT NULL,
	Domain VARCHAR(100) NOT NULL,
	SubDomain VARCHAR(100) NOT NULL,
	TimePeriod VARCHAR(7) NOT NULL,
	LastUpdated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE student_schema.student_academic_details_table (
	ID SERIAL PRIMARY KEY,
	Branch VARCHAR(7) NOT NULL,
	YearOfEnrollment INT CHECK (YearOfEnrollment BETWEEN 1990 AND 2100) NOT NULL,
	CGPA REAL,
	PreviousSemSGPA REAL,
	SchoolForClassTen VARCHAR(255) NOT NULL,
	ClassTenPercentage REAL,
	ClassTenMarksheetID INT NOT NULL UNIQUE,
	SchoolForClassTwelve VARCHAR(255) NOT NULL,
	ClassTwelvePercentage REAL,
	ClassTwelveMarksheetID INT NOT NULL UNIQUE,
	UpdatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE student_schema.student_login_details_table (
	ID SERIAL PRIMARY KEY,
	Email VARCHAR(255) UNIQUE NOT NULL,
	Password VARCHAR(255) NOT NULL,
	Phone VARCHAR(15) NOT NULL
);


================================================
File: pkg/logger/logger.go
================================================
package logger

import (
	"os"

	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

// Logger is a wrapper around zap.Logger that provides structured logging.
type Logger struct {
	zapLogger *zap.Logger
	sugar     *zap.SugaredLogger
	level     zap.AtomicLevel // Added field to store the level
}

// NewLogger creates a new logger instance.
// By default, it writes to stdout and includes timestamps, log levels, and caller information.
func NewLogger() *Logger {
	// Create a new development encoder config
	encoderConfig := zap.NewProductionEncoderConfig()
	encoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	encoderConfig.EncodeLevel = zapcore.CapitalLevelEncoder

	// Create the atomic level and store it
	level := zap.NewAtomicLevelAt(zapcore.InfoLevel)

	// Create a console encoder
	consoleEncoder := zapcore.NewConsoleEncoder(encoderConfig)

	// Create a core that writes to stdout
	core := zapcore.NewCore(
		consoleEncoder,
		zapcore.AddSync(os.Stdout),
		level, // Use the atomic level reference
	)

	// Create a logger with the core and add caller info
	zapLogger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))

	return &Logger{
		zapLogger: zapLogger,
		sugar:     zapLogger.Sugar(),
		level:     level, // Store the level reference
	}
}

// WithField adds a field to the logger.
func (l *Logger) WithField(key string, value any) *Logger {
	return &Logger{
		zapLogger: l.zapLogger.With(zap.Any(key, value)),
		sugar:     l.zapLogger.Sugar().With(key, value),
		level:     l.level, // Maintain the level reference
	}
}

// Debug logs a message at debug level with optional key-value pairs.
func (l *Logger) Debug(msg string, keysAndValues ...any) {
	l.sugar.Debugw(msg, keysAndValues...)
}

// Info logs a message at info level with optional key-value pairs.
func (l *Logger) Info(msg string, keysAndValues ...any) {
	l.sugar.Infow(msg, keysAndValues...)
}

// Warn logs a message at warn level with optional key-value pairs.
func (l *Logger) Warn(msg string, keysAndValues ...any) {
	l.sugar.Warnw(msg, keysAndValues...)
}

// Error logs a message at error level with optional key-value pairs.
func (l *Logger) Error(msg string, keysAndValues ...any) {
	l.sugar.Errorw(msg, keysAndValues...)
}

// Fatal logs a message at fatal level with optional key-value pairs and then exits.
func (l *Logger) Fatal(msg string, keysAndValues ...any) {
	l.sugar.Fatalw(msg, keysAndValues...)
}

// SetLevel sets the logging level.
func (l *Logger) SetLevel(level string) {
	var zapLevel zapcore.Level
	switch level {
	case "debug":
		zapLevel = zapcore.DebugLevel
	case "info":
		zapLevel = zapcore.InfoLevel
	case "warn":
		zapLevel = zapcore.WarnLevel
	case "error":
		zapLevel = zapcore.ErrorLevel
	case "fatal":
		zapLevel = zapcore.FatalLevel
	default:
		zapLevel = zapcore.InfoLevel
	}

	l.level.SetLevel(zapLevel) // Now we can actually set the level
}

// GetLevel returns the current logging level as a string.
func (l *Logger) GetLevel() string {
	level := l.level.Level()
	switch level {
	case zapcore.DebugLevel:
		return "debug"
	case zapcore.InfoLevel:
		return "info"
	case zapcore.WarnLevel:
		return "warn"
	case zapcore.ErrorLevel:
		return "error"
	case zapcore.FatalLevel:
		return "fatal"
	default:
		return "unknown"
	}
}

// Sync flushes any buffered log entries.
func (l *Logger) Sync() error {
	return l.zapLogger.Sync()
}



================================================
File: pkg/pagination/paginator.go
================================================



================================================
File: pkg/security/password.go
================================================



================================================
File: scripts/ci/build.sh
================================================



================================================
File: scripts/ci/test.sh
================================================



================================================
File: scripts/deploy/docker-compose.yml
================================================



================================================
File: scripts/local/setup.sh
================================================



================================================
File: seeds/seed_runner.go
================================================



================================================
File: seeds/development/001_roles.go
================================================



================================================
File: seeds/development/002_admin_users.go
================================================



================================================
File: seeds/development/003_sample_data.go
================================================



================================================
File: seeds/production/default_settings.go
================================================



================================================
File: seeds/production/initial_roles.go
================================================



================================================
File: seeds/testing/test_scenarios.go
================================================



================================================
File: seeds/testing/test_users.go
================================================



================================================
File: test/fixtures/students.json
================================================



================================================
File: test/integration/db_test_helper.go
================================================



================================================
File: test/integration/external/google_test.go
================================================



================================================
File: test/integration/external/onesignal_test.go
================================================



================================================
File: test/integration/external/mock_services/mock_google_api.go
================================================


